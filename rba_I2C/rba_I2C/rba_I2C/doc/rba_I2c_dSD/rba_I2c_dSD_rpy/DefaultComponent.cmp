I-Logix-RPY-Archive version 8.13.0 C 9803352
{ IComponent 
	- _id = GUID 54679677-5bd1-4550-a8de-de072add81ad;
	- _myState = 139264;
	- _name = "DefaultComponent";
	- codeUpdateCGTime = 5.8.2017::7:10:19;
	- _modifiedTimeWeak = 7.4.2017::11:57:58;
	- m_buildType = Executable;
	- m_libraries = "";
	- m_additionalSources = "";
	- m_standardHeaders = "";
	- m_includePath = "";
	- m_initializationCode = "";
	- m_folder = { IFolder 
		- _id = GUID b959c707-f9bb-4d9e-8fa6-90d03e42542a;
		- _myState = 73728;
		- _name = "Files";
		- _modifiedTimeWeak = 7.4.2017::11:33:39;
		- m_path = "..\\..\\..\\..\\workspace\\RhapsodyTr\\Mcal\\rba_I2C\\rba_I2C\\rba_I2C";
		- Elements = { IRPYRawContainer 
			- size = 0;
		}
		- Files = { IRPYRawContainer 
			- size = 7;
			- value = 
			{ IFolder 
				- _id = GUID adac279d-2225-40cd-9df5-9f49fc62a442;
				- _myState = 8192;
				- _name = "src";
				- _modifiedTimeWeak = 7.4.2017::11:33:39;
				- m_path = "";
				- Elements = { IRPYRawContainer 
					- size = 0;
				}
				- Files = { IRPYRawContainer 
					- size = 2;
					- value = 
					{ IFile 
						- _id = GUID 980d70fc-497c-414d-8ebe-b25ddf198077;
						- _myState = 8192;
						- _properties = { IPropertyContainer 
							- Subjects = { IRPYRawContainer 
								- size = 2;
								- value = 
								{ IPropertySubject 
									- _Name = "CG";
									- Metaclasses = { IRPYRawContainer 
										- size = 1;
										- value = 
										{ IPropertyMetaclass 
											- _Name = "File";
											- Properties = { IRPYRawContainer 
												- size = 1;
												- value = 
												{ IProperty 
													- _Name = "HeaderDirectivePattern";
													- _Value = "";
													- _Type = String;
												}
											}
										}
									}
								}
								{ IPropertySubject 
									- _Name = "C_CG";
									- Metaclasses = { IRPYRawContainer 
										- size = 1;
										- value = 
										{ IPropertyMetaclass 
											- _Name = "File";
											- Properties = { IRPYRawContainer 
												- size = 4;
												- value = 
												{ IProperty 
													- _Name = "ImplementationFooter";
													- _Value = "";
													- _Type = MultiLine;
												}
												{ IProperty 
													- _Name = "ImplementationHeader";
													- _Value = "";
													- _Type = MultiLine;
												}
												{ IProperty 
													- _Name = "SpecificationFooter";
													- _Value = "";
													- _Type = MultiLine;
												}
												{ IProperty 
													- _Name = "SpecificationHeader";
													- _Value = "";
													- _Type = MultiLine;
												}
											}
										}
									}
								}
							}
						}
						- _name = "rba_I2CJdp";
						- _modifiedTimeWeak = 7.4.2017::11:33:39;
						- _description = { IDescription 
							- _text = "{\\rtf1\\ansi\\ansicpg1252\\deff0\\deflang1033{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}
\\viewkind4\\uc1\\pard\\fs20\\par
}";
						}
						- m_path = "";
						- m_type = implFile;
						- Fragments = { IRPYRawContainer 
							- size = 6;
							- value = 
							{ IFileFragment 
								- _id = GUID cccd2f3e-7fb1-4a55-9e66-58d9c0b8e117;
								- _name = "/*<RBHead>
 *************************************************************************
 *                                                                       *
 *                      ROBERT BOSCH GMBH                                *
 *                          STUTTGART                                    *
 *                                                                       *
 *          Alle Rechte vorbehalten - All rights reserved                *
 *                                                                       *
 *************************************************************************

 *************************************************************************
 *    Administrative Information (automatically filled in by eASEE)      *
 *************************************************************************
 *
 * $Filename__:$
 *
 * $Author____:$
 *
 * $Function__:$
 *
 *************************************************************************
 * $Domain____:$
 * $User______:$
 * $Date______:$
 * $Class_____:$
 * $Name______:$
 * $Variant___:$
 * $Revision__:$
 * $Type______:$
 * $State_____:$
 * $Generated_:$
 *************************************************************************
 *
 * $UniqueName:$
 * $Component_:$
 *
 *
 *************************************************************************
</RBHead>*/";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "/*<RBHead>
 *************************************************************************
 *                                                                       *
 *                      ROBERT BOSCH GMBH                                *
 *                          STUTTGART                                    *
 *                                                                       *
 *          Alle Rechte vorbehalten - All rights reserved                *
 *                                                                       *
 *************************************************************************

 *************************************************************************
 *    Administrative Information (automatically filled in by eASEE)      *
 *************************************************************************
 *
 * $Filename__:$
 *
 * $Author____:$
 *
 * $Function__:$
 *
 *************************************************************************
 * $Domain____:$
 * $User______:$
 * $Date______:$
 * $Class_____:$
 * $Name______:$
 * $Variant___:$
 * $Revision__:$
 * $Type______:$
 * $State_____:$
 * $Generated_:$
 *************************************************************************
 *
 * $UniqueName:$
 * $Component_:$
 *
 *
 *************************************************************************
</RBHead>*/
";
								- m_startRow = 1;
								- m_startCol_Short = 1;
								- m_endRow = 39;
								- m_endCol_Short = 12;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
							{ IFileFragment 
								- _id = GUID 9685da3e-9883-4fc8-87f4-a5c28055e67a;
								- _name = "/*-------------------------------------------------------------------------------------------------------------------*
 * Includes
 *-------------------------------------------------------------------------------------------------------------------*/
/*!
 * \\rba_comp rba_I2C
 *  @{
 */";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "/*-------------------------------------------------------------------------------------------------------------------*
 * Includes
 *-------------------------------------------------------------------------------------------------------------------*/
/*!
 * \\rba_comp rba_I2C
 *  @{
 */
";
								- m_startRow = 41;
								- m_startCol_Short = 1;
								- m_endRow = 47;
								- m_endCol_Short = 4;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
							{ IFileFragment 
								- _id = GUID b6f3ab6d-12d3-48a6-9d33-9cf5ab1d236b;
								- _name = "directive if";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "#if((MCU_RB_MACHINE_FAM == MCU_RB_JDP_UC1) && (MCU_RB_MACHINE_DEV != MCU_RB_JDP_UC1_DEV1_ALL))";
								- m_startRow = 51;
								- m_startCol_Short = 1;
								- m_endRow = 51;
								- m_endCol_Short = 95;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
							{ IFileFragment 
								- _id = GUID cc32aae7-c4c5-4603-99a9-a08162fd0897;
								- _name = "ifdef - block";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "

#if(RBA_I2C_CFG_MODULE_ACTIVE == STD_ON)

#include   \"rba_BswSrv.h\"
#include   \"rba_I2C_Cfg_SchM.h\"

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
#include \"Det.h\"
#if (!defined(DET_AR_RELEASE_MAJOR_VERSION) || (DET_AR_RELEASE_MAJOR_VERSION != RBA_I2C_AR_RELEASE_MAJOR_VERSION))
#error \"AUTOSAR major version undefined or mismatched\"
#endif
#if (!defined(DET_AR_RELEASE_MINOR_VERSION) || ((DET_AR_RELEASE_MINOR_VERSION != 0) && \\
                                                (DET_AR_RELEASE_MINOR_VERSION != 2)))
#error \"AUTOSAR minor version undefined or mismatched\"
#endif
#endif

#define  RBA_I2C_START_SEC_VAR_CLEARED_UNSPECIFIED
#include RBA_I2C_CFG_MEMMAP_H
    /* I2C module JDP global variable */
    rba_I2c_Seq_Run_tst           rba_I2c_Prv_JdpSeq_Run_st[RBA_I2C_CFG_MAX_CONFIGURED_CHANNELS];    /* I2C Sequence status st */

    /* I2C Sequence transmit/receive status counter */
    rba_I2c_Prv_SeqCount_tst    rba_I2c_Prv_SeqCount_st[RBA_I2C_CFG_MAX_CONFIGURED_CHANNELS];   /* I2C Sequence status st */

#define  RBA_I2C_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include RBA_I2C_CFG_MEMMAP_H

#define  RBA_I2C_START_SEC_VAR_INIT_UNSPECIFIED
#include RBA_I2C_CFG_MEMMAP_H
    /* Port Address Array */
    rba_Reg_I2C_tst* rba_I2c_Prv_Address_apcst[] =
    {   /*  Register Address  */
        (rba_Reg_I2C_tst*)   &I2C0,                  // Index  0  PORT_00
        #if(MCU_RB_MACHINE_DEV == MCU_RB_JDP_UC1_DEV4_ALL)
        (rba_Reg_I2C_tst*)   &I2C1,                  // Index  1  PORT_02
        #endif
    };
#define  RBA_I2C_STOP_SEC_VAR_INIT_UNSPECIFIED
#include RBA_I2C_CFG_MEMMAP_H

//- Functions -----------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//! \\brief Initialize driver specific stuff.
//! Initializes and handles the pre-condition Hardware settings for I2C communication. I2C protocol can support
//! more than one I2C module (hardware), hence init process shall vary based on the number of Configured I2C modules.
//!
//! <b>Sync/Async:</b> Synchronous
//! <b>Reentrancy:</b> Non-reentrant
//!
//! \\param idxHwUnit_qu8: I2C Hardware unit ID.
//!
//! \\return Void
//!
//! \\pre none
//!
///////////////////////////////////////////////////////////////////////////////

#define  RBA_I2C_START_SEC_CODE
#include RBA_I2C_CFG_MEMMAP_H
void rba_I2c_Prv_Hw_Init(uint8 idxHwUnit_qu8)
{
    /* Enable the I2C module setting in the IBCR register */
    rba_I2c_Prv_Address_apcst[ idxHwUnit_qu8 ]->IBCR = (rba_I2c_Prv_Address_apcst[ idxHwUnit_qu8 ]->IBCR) & ( (uint8)(~(1uL << RBA_REG_I2C_IBCR_MDIS_POS)) );

    /* Set the I2C bus to IDLE condition in the IBCR register */
    rba_I2c_Prv_Address_apcst[ idxHwUnit_qu8 ]->IBCR &= (uint8)(~(1uL << RBA_REG_I2C_IBCR_MSSL_POS));

    /* Set to I2C Write Mode in the IBCR register*/
    rba_I2c_Prv_Address_apcst[ idxHwUnit_qu8 ]->IBCR |= (uint8)(1uL << RBA_REG_I2C_IBCR_TXRX_POS);

    /* set ID for Master in the IBAD register */
    rba_I2c_Prv_Address_apcst[ idxHwUnit_qu8 ]->IBAD = RBA_I2C_JDP_SLAVEID;

    /* Set the I2C Clock Divider(default 100KHz) in the IBFD register */
    rba_I2c_Prv_Address_apcst[ idxHwUnit_qu8 ]->IBFD = RBA_I2C_JDP_CLOCK_SPEED_100K;
}

//- Functions -----------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//! \\brief Initialize driver specific stuff.
//! Initializes and handles the pre-condition settings for I2C communication. I2C protocol can support
//! more than one I2C module (hardware), hence init process shall vary based on the number of Configured I2C modules.
//!
//! <b>Sync/Async:</b> Synchronous
//!
//! <b>Reentrancy:</b> Non-reentrant
//!
//! \\param rba_I2c_SeqData_st: interface sequence.
//!
//! \\return Void
//!
//! \\pre none
//!
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void rba_I2c_Prv_Hw_Handler(rba_I2c_SeqDef_tst *rba_I2c_SeqData_st)
{
    /* Private Variable */
    uint8                     xLogicId_u8 = RBA_I2C_ZERO;               /* Generated Logical ID for the Hardware */
    uint8                     xSequenceId_u8 = RBA_I2C_ZERO;            /* Configured Signal ID */
    uint8                     xSlaveId_u8 = RBA_I2C_ZERO;               /* Configured Signal ID */
    uint8                     xHwId_u8 = RBA_I2C_ZERO;                  /* Configured Hardware ID for Signal*/
    Std_ReturnType            stRet = E_NOT_OK;                         /* function Retun value */
    uint8                     xValidateStatus_u8 = 0u;                  /* function Retun value */
    rba_I2c_PriorityType_ten  xSeqPrio_en = RBA_I2C_SEQ_LOW_PRIORITY;   /* Sequence Priority status*/
    uint8                     countVar_u8 = 0u;                         /* Local counter */
    boolean                   xCommunication_status_u8 = TRUE;          /* Local communication status variable */

    /* Read the Sequence Signal ID */
    xSequenceId_u8 = rba_I2c_SeqData_st->rba_I2c_xSequenceCfgId_u8;

    /* Read the Slave ID */
    xSlaveId_u8 = rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[xSequenceId_u8]->SlaveId;

    /* Read the hardware (channel info) Id from the slave configuration dataset.  */
    xHwId_u8 = rba_I2c_prv_cfgConfigType_pcst->slaveConfig_pcst[ xSlaveId_u8 ]->hwConnectID_u8;

    /* Read the logic ID*/
    xLogicId_u8 = rba_I2c_prv_cfgConfigType_pcst->hwUnitConfig_pcst[ xHwId_u8 ]->LogicHwId_u8;

    /* Read the sequence priority */
    xSeqPrio_en = rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[xSequenceId_u8]->sequPrio_en;

    /* common function is start of this place( Polling and interrupt)*/

    /* Check the interrupt status from the initial function */
    /* MISRA warring: Rule CCode_Control_002: Value Test Expression*/
    if ( rba_I2c_Prv_stInterruptMode_b )
    {
        /* enable the Hardware interrupt in the IBCR register  */
        rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR |= (uint8)(1uL << RBA_REG_I2C_IBCR_IBIE_POS);
    }
    else
    {
        /*  Disable the Hardware interrupt in the IBCR register */
        rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR &= (uint8)(~(1uL << RBA_REG_I2C_IBCR_IBIE_POS));
    }

    if(rba_I2c_prv_cfgConfigType_pcst->slaveConfig_pcst[ xSlaveId_u8 ]->baudRate_en == RBA_I2C_SLAVE_NORMAL_MODE )
    {
        rba_I2c_Clk = MCU_RB_US_TO_TICKS(RBA_I2C_CLK_100K); /* One clock cycle for 89KHz -> 1/89KHZ = 11.2359 microseconds */
    }
    else
    {
        rba_I2c_Clk = MCU_RB_US_TO_TICKS(RBA_I2C_CLK_400K); /* One clock cycle for 384KHz -> 1/384KHZ = 2.6041 microseconds */
    }

    /* Copy the sequence to internal variable */
    rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].currentSeq          =  rba_I2c_SeqData_st;
    rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8       =  rba_I2c_SeqData_st->rba_I2c_dataRx_pu8;
    rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataTx_pu8       = rba_I2c_SeqData_st->rba_I2c_dataTx_pu8;
    rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSequenceCfgId_u8 = rba_I2c_SeqData_st->rba_I2c_xSequenceCfgId_u8;
    rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqTxlength_u8   = rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[xSequenceId_u8]->seqTxLen_u8;
    rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8   = rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[xSequenceId_u8]->seqRxLen_u8;
    rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqComType_en    = rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[xSequenceId_u8]->seqComType_en;
    rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqComType_en    = rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[xSequenceId_u8]->seqComType_en;

    /* Reset the Transmit position counter */
    rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].dataTxPosition_u8 = RBA_I2C_ZERO;

    /* Reset the Receive position counter */
    rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].dataRxPosition_u8 = RBA_I2C_ZERO;

    /*wait till bus go to IDLE before start condition (wait till previous sequence send the STOP condition complete  )*/
    /* 100Khz speed each byte transmission time 120us or 400khz for 30us*/
    stRet = rba_I2c_Prv_waitTill_BusIdle(xHwId_u8);

    /* Check the I2C communication bus is idle in the IBSR register*/
    if( (stRet == E_OK ) &&  ( ( ( rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR ) & ( (uint8)(1uL << RBA_REG_I2C_IBCR_MDIS_POS )) ) == 0u )  )
    {
        /* Disable the ACK for Transmission setting in the in the IBCR register and set as Write mode*/
        rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR &= (uint8)(~( 1uL << RBA_REG_I2C_IBCR_NOACK_POS));

        /* Set to I2C Write Mode setting in the IBCR register*/
        rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR |= (uint8)( 1uL << RBA_REG_I2C_IBCR_TXRX_POS );

        /* Frequency setting */
        if(rba_I2c_prv_cfgConfigType_pcst->slaveConfig_pcst[ xSlaveId_u8 ]->baudRate_en == RBA_I2C_SLAVE_NORMAL_MODE )
        {
            /* Set the I2C Clock Divider */
            rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBFD =  RBA_I2C_JDP_CLOCK_SPEED_100K; /* clock setting 89Khz */
        }
        else
        {
            /* Set the I2C Clock Divider */
            rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBFD =  RBA_I2C_JDP_CLOCK_SPEED_400K; /* clock setting 384Khz */
        }

        /* Read the configure 7bit salve unique address from the config dataset*/
        rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].slaveID_u8 = rba_I2c_prv_cfgConfigType_pcst->slaveConfig_pcst[ xSlaveId_u8 ]->slaveAddress_u8;

        /* Send Start command to the Slave device*/
        rba_I2c_JdpStart( xHwId_u8 );

        /* Wait till I2C bus go to busy state */
        stRet =  rba_I2c_Prv_waitTill_BusBusy( xHwId_u8);

        if(stRet == E_NOT_OK )
        {
#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
            /* Call DET error for Timeout slave interface */
            (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                  RBA_I2C_DET_ERR_JDP_I2C_START_FAILURE);
#endif
            /* Execute the Sequence End transmission process */
            rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                    xSeqPrio_en, rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_I2C_START_FAILURE);

        }

        else
        {
            /* Clear the I2C module interrupt*/
            rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR |= (uint8)( 1uL << RBA_REG_I2C_IBSR_IBIF_POS );

            /* Check whether the communication type is Receive */
            if(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqComType_en == rba_I2c_Rx_e)
            {
                /* Send the Slave id in I2C bus for the Receive mode*/
                rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBDR = rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].slaveID_u8 + RBA_I2C_RECEIVE_MODE;
            }
            else
            {
                /* Send the Slave id in I2C bus for the Transmit mode */
                rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBDR = rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].slaveID_u8 + RBA_I2C_TRANSMIT_MODE;
            }

            /* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Polling Mode Interface start ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
            /* Check whether the interrupt is enable or not */
            if(rba_I2c_Prv_stInterruptMode_b == FALSE)
            {
                /* Validate the last byte(Slave ID) transmission */
                xValidateStatus_u8 = rba_I2c_Prv_ValidateTransmissionStatus( xHwId_u8, RBA_I2C_SLAVEADD_LEN);

                /* check the return status of \"Validate Transmission Status\" function */
                if(xValidateStatus_u8 == RBA_I2C_JDP_TX_COMPLETE_CHK_FAILED )
                {

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                    /* Call DET error for Timeout slave interface */
                    (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                          RBA_I2C_DET_ERR_JDP_POL_TX_ID_NOT_COMPLETED);
#endif

                    /* Execute the Sequence End transmission process */
                    rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                        xSeqPrio_en, rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_POL_TX_ID_NOT_COMPLETED);


                }
                else if(xValidateStatus_u8 == RBA_I2C_JDP_TX_ACK_NOT_RECEIVED_FAILED)
                {
#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                    /* Call DET error for Timeout slave interface */
                    (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                            RBA_I2C_DET_ERR_JDP_POL_TX_ID_ACK_NOT_RECEIVED);
#endif

                    /* Execute the Sequence End transmission process */
                    rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                            xSeqPrio_en, rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_POL_TX_ID_ACK_NOT_RECEIVED);
                }
                else
                {
                    /* Check the communication Type Transmit or Combined Transmit or Receive */
                    if(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqComType_en == rba_I2c_Tx_e)
                    {
                        /* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Polling-Transmit sequence execution start ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */


                        /* Send the all Transmit data in the sequence */
                        for(countVar_u8 = 0u; countVar_u8 < rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqTxlength_u8; countVar_u8++)
                        {
                            rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].dataTxPosition_u8 = countVar_u8 ;

                            /* before transmit the next byte Clear the I2C module interrupt status Flag*/
                            rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR |=  ((uint8)( 1uL << RBA_REG_I2C_IBSR_IBIF_POS ));

                            /* Send the Write data to the Slave device*/
                            rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBDR = rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataTx_pu8[ rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].dataTxPosition_u8 ];

                            /* Validate the each byte transmission */
                            xValidateStatus_u8 = rba_I2c_Prv_ValidateTransmissionStatus(xHwId_u8, rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqTxlength_u8);

                            /* check the return status of \"Validate Transmission Status\" function */
                            if(xValidateStatus_u8 == RBA_I2C_JDP_TX_COMPLETE_CHK_FAILED )
                            {
                                /* set communication status to failure */
                                xCommunication_status_u8 = FALSE;

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                /* Call DET error for Timeout slave interface */
                                (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                                      RBA_I2C_DET_ERR_JDP_POL_TX_NOT_COMPLETED);
#endif

                                /* Execute the Sequence End transmission process */
                                rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8, xSeqPrio_en,
                                                        rba_I2c_SeqFailed_e,RBA_I2C_ERR_SEQ_JDP_POL_TX_NOT_COMPLETED );

                            }
                            else
                            {
							    if(xValidateStatus_u8 == RBA_I2C_JDP_TX_ACK_NOT_RECEIVED_FAILED)
								{
                                /* set communication status to failure */
                                xCommunication_status_u8 = FALSE;

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                /* Call DET error for Timeout slave interface */
                                (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                                      RBA_I2C_DET_ERR_JDP_POL_TX_ACK_NOT_RECEIVED);
#endif

                                /* Execute the Sequence End transmission process */
                                rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                        xSeqPrio_en, rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_POL_TX_ACK_NOT_RECEIVED);
                                }
                            }
                            /* for the error communication stop the I2C interface */
                            if(xCommunication_status_u8 == FALSE)
                            {
                                break;
                            }
                        }
                        if( xCommunication_status_u8 == TRUE )
                        {

                            /* Send Stop command to the Slave device*/
                            rba_I2c_JdpStop(xHwId_u8);

                            /* Execute the Sequence End transmission process */
                            rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8, xSeqPrio_en,
                               rba_I2c_SeqCompleted_e, E_OK);
                        }

                           /* ^^^^^^^^^^^^^^^^ Polling-Transmit sequence execution End ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
                    }
                    else if(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqComType_en == rba_I2c_CombinedTxRx_e)
                    {
                        /* ^^^^^^^^^^ Polling-Transmit combined Receive sequence execution start ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

                        /* Send the all Transmit data */
                        for(countVar_u8 = 0u; countVar_u8 <= rba_I2c_Prv_JdpSeq_Run_st[xLogicId_u8].runSeqTxlength_u8; countVar_u8++)
                        {

                            rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].dataTxPosition_u8 = countVar_u8;

                            /* check whether the tranfering the laster byte in I2C interface */
                            if( rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].dataTxPosition_u8 >= rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqTxlength_u8)
                            {
                                /* Clear the I2C module interrupt*/
                                rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR |=  (uint8)( 1uL << RBA_REG_I2C_IBSR_IBIF_POS );

                                /* Send Repeat Start command to the I2C Channel */
                                rba_I2c_JdpReStart(xHwId_u8);

                                /* create a delay for bus go to busy state */
                                stRet = rba_I2c_Prv_waitTill_BusBusy(xHwId_u8);

                                /* check the return status of \"rba_I2c_Prv_waitTill_BusBusy\" function */
                                if( stRet != E_OK)
                                {
                                    /* failure condition break the for loop */
                                    /* set communication status to failure */
                                    xCommunication_status_u8 = FALSE;

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                    /* Call DET error for Timeout slave interface */
                                    (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                           RBA_I2C_DET_ERR_JDP_POL_COMB_TX_RX_BUS_NOT_BUSY);
#endif

                                    /* Execute the Sequence End transmission process */
                                    rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                           xSeqPrio_en, rba_I2c_SeqFailed_e,RBA_I2C_ERR_SEQ_JDP_POL_COMB_TX_RX_BUS_NOT_BUSY );


                                }
                                else
                                {
                                    /* Change I2C bus to receive Mode Send Slave ID in I2C channel*/
                                    rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBDR = rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].slaveID_u8 + RBA_I2C_RECEIVE_MODE;

                                    /* Validate the last byte transmission status*/
                                    xValidateStatus_u8 = rba_I2c_Prv_ValidateTransmissionStatus( xHwId_u8, RBA_I2C_SLAVEADD_LEN);

                                    /* check the return status of \"rba_I2c_Prv_ValidateTransmissionStatus\" function */
                                    if(xValidateStatus_u8 == RBA_I2C_JDP_TX_COMPLETE_CHK_FAILED )
                                    {
                                        /* failure condition break the for loop */
                                        /* set communication status to failure */
                                        xCommunication_status_u8 = FALSE;

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                        /* Call DET error for Timeout slave interface */
                                        (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                                              RBA_I2C_DET_ERR_JDP_POL_COMB_TX_LAST_BYTE_NOT_COMPLETED);
#endif

                                        /* Execute the Sequence End transmission process */
                                        rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                                                       xSeqPrio_en,rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_POL_COMB_TX_LAST_BYTE_NOT_COMPLETED);

                                    }
                                    else
                                    {
									if(xValidateStatus_u8 == RBA_I2C_JDP_TX_ACK_NOT_RECEIVED_FAILED)
									{
                                        /* failure condition break the for loop */
                                        /* set communication status to failure */
                                        xCommunication_status_u8 = FALSE;

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                        /* Call DET error for Timeout slave interface */
                                        (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                                RBA_I2C_DET_ERR_JDP_POL_COMB_TX_LAST_BYTE_ACK_NOT_RECEIVED);
#endif

                                        /* Execute the Sequence End transmission process */
                                        rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                               xSeqPrio_en, rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_POL_COMB_TX_LAST_BYTE_ACK_NOT_RECEIVED);

                                    }
                                    }
                                }
                            }
                            else
                            {
                                /* Clear the I2C module interrupt*/
                                rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR |=  ((uint8)( 1uL << RBA_REG_I2C_IBSR_IBIF_POS ));

                                /* Send the data to I2C Bus */
                                rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBDR = rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataTx_pu8[ rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].dataTxPosition_u8 ];

                                /* Validate the Transmission */
                                xValidateStatus_u8 = rba_I2c_Prv_ValidateTransmissionStatus( xHwId_u8, rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqTxlength_u8);

                                /* check the return status of \"rba_I2c_Prv_ValidateTransmissionStatus\" function */
                                if(xValidateStatus_u8 == RBA_I2C_JDP_TX_COMPLETE_CHK_FAILED)
                                {

                                    /* failure condition break the for loop */
                                    /* set communication status to failure */
                                    xCommunication_status_u8 = FALSE;


#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                    /* Call DET error for Transmit not completed */
                                    (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                           RBA_I2C_DET_ERR_JDP_POL_COMB_TX_NOT_COMPLETED);
#endif

                                    /* Execute the Sequence End transmission process */
                                    rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                           xSeqPrio_en, rba_I2c_SeqFailed_e,  RBA_I2C_ERR_SEQ_JDP_POL_COMB_TX_NOT_COMPLETED);


                                }
                                else
                                {
								if(xValidateStatus_u8 == RBA_I2C_JDP_TX_ACK_NOT_RECEIVED_FAILED)
								{

                                    /* failure condition break the for loop */
                                    /* set communication status to failure */
                                    xCommunication_status_u8 = FALSE;

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                    /* Call DET error for Timeout slave interface */
                                    (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                           RBA_I2C_DET_ERR_JDP_POL_COMB_TX_ACK_NOT_RECEIVED);
#endif

                                    /* Execute the Sequence End transmission process */
                                    rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                           xSeqPrio_en, rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_POL_COMB_TX_ACK_NOT_RECEIVED);

                                }
                                }
                            }

                            /* for the error communication stop the I2C interface */
                            if(xCommunication_status_u8 == FALSE)
                            {
                                break;
                            }

                        }

                        /* check whether transmission is sucess */
                        if(xCommunication_status_u8 == TRUE)
                        {
                            if(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8 > 1u)
                            {
                                /* Enable  the ACK for Transmission */
                                rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR &= ((uint8)~(1uL << RBA_REG_I2C_IBCR_NOACK_POS));
                            }
                            else
                            {
                                /* Disable the ACK for Transmission */
                                rba_I2c_Prv_Address_apcst[xHwId_u8]->IBCR |= (uint8)(1uL << RBA_REG_I2C_IBCR_NOACK_POS);
                            }

                            /* Set to I2C Read Mode*/
                            rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR &= ((uint8)~(1uL << RBA_REG_I2C_IBCR_TXRX_POS));

                            /* Dummy Read required for as mentioned the JDP User Manuel */
                            *(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8) = (rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBDR);

                            /* Wait till complete the receive condition */
                            stRet = rba_I2c_Prv_RxComplete_Chk(xHwId_u8, rba_I2c_Prv_JdpSeq_Run_st[xLogicId_u8].runSeqRxlength_u8);

                            /* check the first byte transmission status failure*/
                            if( stRet == E_NOT_OK)
                            {
                                /* set communication status to failure */
                                xCommunication_status_u8 = FALSE;

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                /* Call DET error for Timeout slave interface */
                                (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                                      RBA_I2C_DET_ERR_JDP_POL_COMB_RX_DUMMY_NOT_COMPLETED);
#endif
                                /* Execute the Sequence End transmission process */
                                rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                       xSeqPrio_en, rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_POL_COMB_RX_DUMMY_NOT_COMPLETED);


                            }
                            else
                            {

                                for( countVar_u8 = 0u; countVar_u8 < rba_I2c_Prv_JdpSeq_Run_st[xLogicId_u8].runSeqRxlength_u8; countVar_u8++ )
                                {
                                    rba_I2c_Prv_SeqCount_st[xLogicId_u8].dataRxPosition_u8 = countVar_u8;

                                    if( ( rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].dataRxPosition_u8 + 1u) == rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8 )
                                    {

                                        /* Clear the Bus Interrupt Flag. */
                                        rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR |= (uint8)(1uL << RBA_REG_I2C_IBSR_IBIF_POS);

                                        /* Send Stop command to the Slave device*/
                                        rba_I2c_JdpStop(xHwId_u8);

                                        /* Read the Data from the Data Register */
                                        *(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8) = ( rba_I2c_Prv_Address_apcst[xHwId_u8]->IBDR );

                                        /* Set to I2C Write Mode setting in the IBCR register*/
                                        rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR |= (uint8)( 1uL << RBA_REG_I2C_IBCR_TXRX_POS );

                                        /* Execute the Sequence End transmission process */
                                        rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8, xSeqPrio_en,
                                               rba_I2c_SeqCompleted_e, E_OK);

                                    }
                                    else if( ( (rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].dataRxPosition_u8) + 2u) == rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8 )
                                    {
                                        /* Disable the ACK before 2nd byte */
                                        rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR |= (uint8)( 1uL << RBA_REG_I2C_IBCR_NOACK_POS);

                                        /* Clear the I2C module interrupt*/
                                        rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR |= (uint8)( 1uL << RBA_REG_I2C_IBSR_IBIF_POS );

                                        /* Read the Data from the Data Register */
                                        *(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8)  =
                                               ( rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBDR );

                                        /* Pointer increment Misra warring need place */
                                        rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8++;

                                        /* Wait till complete the receive condition */
                                        stRet = rba_I2c_Prv_RxComplete_Chk(xHwId_u8, rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8);

                                        /* check the first byte transmission status failure*/
                                        if( stRet == E_NOT_OK)
                                        {

                                            /* set communication status to failure */
                                            xCommunication_status_u8 = FALSE;


#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                            /* Call DET errror for Timeout slave interface */
                                            (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                                                  RBA_I2C_DET_ERR_JDP_POL_COMB_RX_LAST_BYTE_NOT_COMPLETED);
#endif

                                            /* Execute the Sequence End transmission process */
                                            rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                                   xSeqPrio_en, rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_POL_COMB_RX_LAST_BYTE_NOT_COMPLETED);


                                        }
                                    }
                                    else
                                    {
                                        /* Clear the I2C module interrupt*/
                                        rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR |=  (uint8)( 1uL << RBA_REG_I2C_IBSR_IBIF_POS );

                                        /* Read the Data from the Data Register */
                                        *(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8)  =
                                               ( rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBDR );

                                        /* Misra warring removal */
                                        rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8++;

                                        /* Wait till complete the receive condition */
                                        stRet = rba_I2c_Prv_RxComplete_Chk(xHwId_u8, rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8);

                                        /* check the first byte transmission status failure*/
                                        if( stRet == E_NOT_OK)
                                        {

                                            /* set communication status to failure */
                                            xCommunication_status_u8 = FALSE;

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                            /* Call DET error for Timeout slave interface */
                                            (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                                   RBA_I2C_DET_ERR_JDP_POL_COMB_RX_NOT_COMPLETED);
#endif

                                            /* Execute the Sequence End transmission process */
                                            rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                                                           xSeqPrio_en, rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_POL_COMB_RX_NOT_COMPLETED);


                                        }
                                    }


                                    /* for the error communication stop the I2C interface- aand break the \"for\" loop */
                                    if(xCommunication_status_u8 == FALSE)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                       /* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Polling-Transmit combined Receive sequence execution End ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */
                    }
                   else
                   {
                       /* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Polling-Receive sequence execution start ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */
                       if (rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqComType_en == rba_I2c_Rx_e)
					   {
                       if(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8 > 1u)
                       {
                           /* Enable  the ACK for Transmission */
                           rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR &= ((uint8)~(1uL << RBA_REG_I2C_IBCR_NOACK_POS));
                       }
                       else
                       {
                           /* Disable the ACK for Transmission */
                           rba_I2c_Prv_Address_apcst[xHwId_u8]->IBCR |= ((uint8)(1uL << RBA_REG_I2C_IBCR_NOACK_POS));
                       }

                       /* Set to I2C Read Mode*/
                       rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR &= ((uint8)~(1uL << RBA_REG_I2C_IBCR_TXRX_POS));

                       /* Dummy Read required for as mentioned the JDP User Manuel */
                       *(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8) = (rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBDR);

                       /* Wait till complete the receive condition */
                       stRet = rba_I2c_Prv_RxComplete_Chk(xHwId_u8, rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8);

                       /* check the first byte transmission status failure*/
                       if( stRet == E_NOT_OK)
                       {
                           /* set communication status to failure */
                           xCommunication_status_u8 = FALSE;

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                           /* Call DET error for Timeout slave interface */
                           (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                   RBA_I2C_DET_ERR_JDP_POL_RX_DUMMY_NOT_COMPLETED);
#endif
                           /* Execute the Sequence End transmission process */
                           rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                   xSeqPrio_en, rba_I2c_SeqFailed_e,
                                   RBA_I2C_ERR_SEQ_JDP_POL_RX_DUMMY_NOT_COMPLETED);


                       }
                       else
                       {

                           for( countVar_u8 = 0u; countVar_u8 < rba_I2c_Prv_JdpSeq_Run_st[xLogicId_u8].runSeqRxlength_u8; countVar_u8++ )
                           {

                               rba_I2c_Prv_SeqCount_st[xLogicId_u8].dataRxPosition_u8 = countVar_u8;

                               if( ( rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].dataRxPosition_u8 + 1u) == rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8  )
                               {
                                   /* Clear the Bus Interrupt Flag. */
                                   rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR |= (uint8)(1uL << RBA_REG_I2C_IBSR_IBIF_POS);

                                   /* Send Stop command to the Slave device*/
                                   rba_I2c_JdpStop(xHwId_u8);

                                   /* Read the Data from the Data Register */
                                   *(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8) = ( rba_I2c_Prv_Address_apcst[xHwId_u8]->IBDR );

                                   /* Set to I2C Write Mode setting in the IBCR register*/
                                   rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR |= (uint8)( 1uL << RBA_REG_I2C_IBCR_TXRX_POS );

                                   /* Execute the Sequence End transmission process */
                                   rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8, xSeqPrio_en,
                                           rba_I2c_SeqCompleted_e, E_OK);


                               }
                               else if( ( (rba_I2c_Prv_SeqCount_st[ xLogicId_u8 ].dataRxPosition_u8) + 2u) == rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8  )
                               {
                                   /* Disable the ACK before 2nd byte */
                                   rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR |= (uint8)(1uL << RBA_REG_I2C_IBCR_NOACK_POS);

                                   /* Clear the I2C module interrupt*/
                                   rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR |= (uint8)( 1uL << RBA_REG_I2C_IBSR_IBIF_POS );

                                   /* Read the Data from the Data Register */
                                   *(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8)  =
                                           ( rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBDR );

                                   /* Pointer increment Misra warring need place */
                                   rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8++;

                                   /* Wait till complete the receive condition */
                                   stRet = rba_I2c_Prv_RxComplete_Chk(xHwId_u8, rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8);

                                   /* check the first byte transmission status failure*/
                                   if( stRet == E_NOT_OK)
                                   {
                                       /* set communication status to failure */
                                       xCommunication_status_u8 = FALSE;

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                       /* Call DET error for Timeout slave interface */
                                       (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                               RBA_I2C_DET_ERR_JDP_POL_RX_LAST_BYTE_NOT_COMPLETED);
#endif

                                       /* Execute the Sequence End transmission process */
                                       rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                               xSeqPrio_en, rba_I2c_SeqFailed_e,
                                               RBA_I2C_ERR_SEQ_JDP_POL_RX_LAST_BYTE_NOT_COMPLETED);

                                   }
                               }
                               else
                               {
                                   /* Clear the I2C module interrupt*/
                                   rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR |=  (uint8)( 1uL << (RBA_REG_I2C_IBSR_IBIF_POS ));

                                   /* Read the Data from the Data Register */
                                   *(rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8)  =
                                           ( rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBDR );

                                   /* Misra warring removal */
                                   rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runDataRx_pu8++;

                                   /* Wait till complete the receive condition */
                                   stRet = rba_I2c_Prv_RxComplete_Chk(xHwId_u8, rba_I2c_Prv_JdpSeq_Run_st[ xLogicId_u8 ].runSeqRxlength_u8);

                                   /* check the first byte transmission status failure*/
                                   if( stRet == E_NOT_OK)
                                   {

                                       /* set communication status to failure */
                                       xCommunication_status_u8 = FALSE;

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                       /* Call DET error for Timeout slave interface */
                                       (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                                               RBA_I2C_DET_ERR_JDP_POL_RX_NOT_COMPLETED);
#endif

                                       /* Execute the Sequence End transmission process */
                                       rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                                               xSeqPrio_en, rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_POL_RX_NOT_COMPLETED);


                                   }
                               }

                               /* for the error communication stop the I2C interface */
                               if(xCommunication_status_u8 == FALSE)
                               {
                                   break;
                               }

                           }

                       }



                       /* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Polling-Receive sequence execution End ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */
                   }
                   }
                }
            }   /*          if(rba_I2c_Prv_stInterruptMode_b == FALSE)*/
            /* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Polling Mode Interface End ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */
        }
    }
    else
    {
#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
        /* Call DET error for Timeout slave interface */
        (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_HANDLER,
                RBA_I2C_DET_ERR_JDP_I2C_BUS_NOT_IDLE);
#endif


        /* Execute the Sequence End transmission process */
        rba_I2c_Prv_SeqEndTransmission(xSequenceId_u8, xHwId_u8, xLogicId_u8,
                xSeqPrio_en, rba_I2c_SeqFailed_e, RBA_I2C_ERR_SEQ_JDP_I2C_BUS_NOT_IDLE);
    }
}

#ifdef RBA_I2C_ENABLE_DEINIT
//- Functions -----------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//! \\brief Disable initialize driver specific stuff.
//! Uninitialized and handles the pre-condition settings for I2C communication. I2C protocol can support
//! more than one I2C module (hardware), hence init process shall vary based on the number of Configured I2C modules.
//!
//! <b>Sync/Async:</b> Synchronous
//!
//! <b>Reentrancy:</b> Non-reentrant
//!
//! \\param idxHwUnit_qu8: I2C hardware unit ID .
//!
//! \\return Void
//!
//! \\pre none
//!
///////////////////////////////////////////////////////////////////////////////
void rba_I2c_Prv_Hw_DeInit(uint8 idxHwUnit_qu8)
{
    /* Clear the Present interrupt */
    rba_I2c_Prv_Address_apcst[ idxHwUnit_qu8 ]->IBSR |= (uint8)(1uL << RBA_REG_I2C_IBSR_IBIF_POS);

    /* Set to I2C Read Mode*/
    rba_I2c_Prv_Address_apcst[ idxHwUnit_qu8 ]->IBCR |= (uint8)(1uL << RBA_REG_I2C_IBCR_TXRX_POS);

    /* Disable the ACK for Transmission */
    rba_I2c_Prv_Address_apcst[ idxHwUnit_qu8 ]->IBCR |= (uint8)(1uL << RBA_REG_I2C_IBCR_NOACK_POS);

    /* Send Stop command to the Slave device*/
    rba_I2c_JdpStop(idxHwUnit_qu8);
}
#endif /* #ifdef RBA_I2C_ENABLE_DEINIT */

//- Functions -----------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//! \\brief
//! Validate the Transmit complete sequence.
//!
//!
//! <b>Sync/Async:</b> Synchronous
//!
//! <b>Reentrancy:</b> reentrant
//!
//! \\param xHwId_u8:                 I2C Hardware ID
//!
//! \\return \\return E_OK is success, E_NOT_OK is failure execution
//!
//! \\pre None
//!
///////////////////////////////////////////////////////////////////////////////
Std_ReturnType rba_I2c_Prv_TxComplete_Chk(uint8 xHwId_u8, uint8 runSeqTxlength_u8)
{
    /* Local variable */
    Std_ReturnType   stRet = E_NOT_OK;                /* Return status variable */
    uint32 current_Ticks_u32 = 0uL;
    uint32 initial_Ticks_u32 = Mcu_Rb_GetSysTicks();
    /*The waiting time is made for two times the Transmission length.
     * This buffer time is provided by taking into consideration,
     * the time needed to update the registers, stop bit, etc., */
    uint32 rba_I2C_Prv_JdpTimeout_Max_u32 = 2*runSeqTxlength_u8*BYTE_LENGTH*rba_I2c_Clk;

    /* Timeout checking for First byte Transmission completed*/
    while(current_Ticks_u32 < rba_I2C_Prv_JdpTimeout_Max_u32)
    {

        if( ( ( (rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR)  & ( (uint8)(1uL << RBA_REG_I2C_IBSR_IBIF_POS) ) ) != 0 )
         && ( ( (rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR)  & ( (uint8)(1uL << RBA_REG_I2C_IBSR_TCF_POS) ) ) != 0 ) )
        {
            /* break counter value because Transmit completed successfully */
            current_Ticks_u32 = rba_I2C_Prv_JdpTimeout_Max_u32;

            /* Set the return value to TX completed success */
            stRet = E_OK;
        }
        else
        {
            /* Update the current system Tick value */
            current_Ticks_u32 = Mcu_Rb_GetSysTicks() - initial_Ticks_u32;
        }
    }

    /* Return the function status */
    return  stRet;
}

//- Functions -----------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//! \\brief
//! Validate the Receive sequence.
//!
//!
//! <b>Sync/Async:</b> Synchronous
//!
//! <b>Reentrancy:</b> reentrant
//!
//! \\param xHwId_u8:                 I2C Hardware ID
//!
//! \\return \\return E_OK is success, E_NOT_OK is failure execution
//!
//! \\pre None
//!
///////////////////////////////////////////////////////////////////////////////
Std_ReturnType rba_I2c_Prv_RxComplete_Chk(uint8 xHwId_u8, uint8 runSeqRxlength_u8)
{
    /* Local variable */
    Std_ReturnType   stRet = E_NOT_OK;   /* Return status variable */
    uint32 current_Ticks_u32 = 0uL;
    uint32 initial_Ticks_u32 = Mcu_Rb_GetSysTicks();
    /*The waiting time is made for two times the Receive sequence length.
     * This buffer time is provided by taking into consideration,
     * the time needed to update the registers, stop bit, etc., */
    uint32 rba_I2C_Prv_JdpTimeout_Max_u32 = 2*runSeqRxlength_u8*BYTE_LENGTH*rba_I2c_Clk;

    /* Timeout checking for First byte Transmission completed*/
    while(current_Ticks_u32 < rba_I2C_Prv_JdpTimeout_Max_u32)
    {

        if ( ( ( (rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR)  & ( (uint8)(1uL << RBA_REG_I2C_IBSR_IBIF_POS) ) ) != 0 )
            && ( ( (rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR)  & ( (uint8)(1uL << RBA_REG_I2C_IBSR_TCF_POS) ) ) != 0 ) )
        {
            /* break counter value because Receive completed successfully */
            current_Ticks_u32 = rba_I2C_Prv_JdpTimeout_Max_u32;

            /* Set the return value to TX completed success */
            stRet = E_OK;
        }
        else
        {
            /* Update the current system Tick value */
            current_Ticks_u32 = Mcu_Rb_GetSysTicks() - initial_Ticks_u32;
        }
    }

/* Return the function status */
    return  stRet;
}
//- Functions -----------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//! \\brief
//! Validate the Acknowledge received for the sequence.
//!
//!
//! <b>Sync/Async:</b> Synchronous
//!
//! <b>Reentrancy:</b> reentrant
//!
//! \\param xHwId_u8:                 I2C Hardware ID
//!
//! \\return \\return E_OK is success, E_NOT_OK is failure execution
//!
//! \\pre None
//!
///////////////////////////////////////////////////////////////////////////////
Std_ReturnType rba_I2c_Prv_AckRecive_Chk(uint8 xHwId_u8)
{
    /* Local variable */
    Std_ReturnType    stRet = E_NOT_OK;   /* Return status variable */

    /* Check the Acknowledge is received */
    if( ( (rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR) & ( (uint8)(1uL << RBA_REG_I2C_IBSR_RXAK_POS) ) )  == 0 )
    {
        /* Set the return value to Acknowledge received */
        stRet = E_OK;
    }
    else
    {
        /* Set the return value to Acknowledge Failure */
        stRet = E_NOT_OK;
    }
    return stRet;
}

//- Functions -----------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//! \\brief
//! Last byte transmit data Validation. This function will check the Transfer complete status form the register and
//! validate the Receive acknowledge. if any one condition is failure return the failure status.
//!
//! <b>Sync/Async:</b> Synchronous
//!
//! <b>Reentrancy:</b> reentrant
//!
//! \\param xHwId_u8:                 I2C Hardware ID
//!
//! \\return \\return E_OK is success, E_NOT_OK is failure execution
//!
//! \\pre None
//!
///////////////////////////////////////////////////////////////////////////////
uint8 rba_I2c_Prv_ValidateTransmissionStatus(uint8 xHwId_u8, uint8 runSeqTxlength_u8)
{
    /* Local variable */
    Std_ReturnType       stVal = E_NOT_OK;
    uint8   rba_I2C_Prv_TxComplete_Chk_Status_u8 = RBA_I2C_JDP_TX_COMPLETE_CHK_PASS;
    /* ***************************get the first byte transmission stauts************************************************************** */
    stVal = rba_I2c_Prv_TxComplete_Chk(xHwId_u8, runSeqTxlength_u8);

    /* check the first byte transmission status failure*/
    if( stVal == E_NOT_OK)
    {
        rba_I2C_Prv_TxComplete_Chk_Status_u8 = RBA_I2C_JDP_TX_COMPLETE_CHK_FAILED;
    }
    else
    {
    /* Check the ACK */
         stVal = rba_I2c_Prv_AckRecive_Chk(xHwId_u8);

    /* check the first byte transmission status failure*/
         if( stVal == E_NOT_OK)
         {
             rba_I2C_Prv_TxComplete_Chk_Status_u8 = RBA_I2C_JDP_TX_ACK_NOT_RECEIVED_FAILED;
         }

    }
    return rba_I2C_Prv_TxComplete_Chk_Status_u8;

}

//- Functions -----------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//! \\brief
//! This function create delay to till I2C go to BUSY state.
//!
//!
//! <b>Sync/Async:</b> Synchronous
//!
//! <b>Reentrancy:</b> reentrant
//!
//! \\param xHwId_u8:                 I2C Hardware ID
//!
//! \\return : E_OK is sucess, E_NOT_OK is failure execution
//!
//! \\pre None
//!
///////////////////////////////////////////////////////////////////////////////
Std_ReturnType rba_I2c_Prv_waitTill_BusBusy(uint8 xHwId_u8)
{
    /*wait till bus go to IDLE before start condition (wait till previous sequence send the STOP condition complete  )*/
    Std_ReturnType   stRet = E_NOT_OK;           /* Return status variable */
    uint32 current_Ticks_u32 = 0uL;
    uint32 initial_Ticks_u32 = Mcu_Rb_GetSysTicks();

    /* Timeout checking for First byte Transmission completed*/
    /* The waiting time is made for four times the I2c clock pulse.
     * This buffer time is provided by taking into consideration,
     * the time needed to update the registers, time needed by I2c to
     * switch , etc., */
    while(current_Ticks_u32 < (4u*rba_I2c_Clk))
    {
         /* check the bus enters into busy state*/
         if( ( (rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR)  &  ((uint8)(1uL << RBA_REG_I2C_IBSR_IBB_POS) ) ) != 0uL )
         {
             current_Ticks_u32 = 4u*rba_I2c_Clk;
             /* Set the return value to TX completed success */
             stRet  = E_OK;
         }
         else
         {
              /* Update the current system Tick value */
              current_Ticks_u32 = Mcu_Rb_GetSysTicks() - initial_Ticks_u32;
         }
    }
    /* Return the function status */
    return  stRet;
}

//- Functions -----------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//! \\brief
//! This function create delay to till I2C go to IDLE state.
//!
//!
//! <b>Sync/Async:</b> Synchronous
//! <b>Reentrancy:</b> reentrant
//!
//! \\param xHwId_u8:                 I2C Hardware ID
//!
//! \\return \\return E_OK is success, E_NOT_OK is failure execution
//!
//! \\pre None
//!
///////////////////////////////////////////////////////////////////////////////
Std_ReturnType rba_I2c_Prv_waitTill_BusIdle(uint8 xHwId_u8)
{
        Std_ReturnType   stRet = E_NOT_OK;           /* Return status variable */
        uint32 current_Ticks_u32 = 0uL;
        uint32 initial_Ticks_u32 = Mcu_Rb_GetSysTicks();

        /* Timeout checking for First byte Transmission completed*/
        /* The waiting time is made for four times the I2c clock pulse.
         * This buffer time is provided by taking into consideration,
         * the time needed to update the registers, time needed by I2c to
         * switch , etc., */
        while(current_Ticks_u32 < (4u*rba_I2c_Clk))
        {
             /* check the bus enters into busy state*/
            if( ( (rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR)  & ((uint8)(1uL << RBA_REG_I2C_IBSR_IBB_POS) ) ) == RBA_I2C_ZERO )
             {
			 /* Reset the counter */
                 current_Ticks_u32 = 4u*rba_I2c_Clk;
                 /* Set the return value to TX completed success */
                 stRet  = E_OK;
             }
             else
             {
                  /* Update the current system Tick value */
                  current_Ticks_u32 = Mcu_Rb_GetSysTicks() - initial_Ticks_u32;
             }
        }

    /* Return the function status */
    return  stRet;

}

//- Functions -----------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//! \\brief
//! for every byte transmission complte reset the I2C hardware registers and reset the I2C software variable.
//! <b>Sync/Async:</b> Synchronous
//!
//! <b>Reentrancy:</b> reentrant
//!
//! \\param xSequenceId_u8:           request sequence
//! \\param xHwId_u8:                 I2C Hardware ID
//! \\param xLogicId_u8:              I2C Logical ID
//! \\param xSeqPrio_en:              I2C sequence priorty
//! \\param xSeqStatus:               I2C Logical ID
//! \\param xErrorID_u8:              I2C Logical ID
//!
//! \\return  void
//!
//! \\pre None
//!
///////////////////////////////////////////////////////////////////////////////
void rba_I2c_Prv_SeqEndTransmission(uint8 xSequenceId_u8, uint8 xHwId_u8, uint8 xLogicId_u8,
        rba_I2c_PriorityType_ten xSeqPrio_en, rba_I2c_xSeqStatus_ten xSeqStatus, uint8 xErrorID_u8 )
{
    /* Enable the I2C bus and default setting */
    rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBCR |= (uint8)(1uL << RBA_REG_I2C_IBCR_NOACK_POS);

    /* Clear the Bus Interrupt Flag. */
    rba_I2c_Prv_Address_apcst[ xHwId_u8 ]->IBSR |= (uint8)(1uL << RBA_REG_I2C_IBSR_IBIF_POS);

    /* After complete the sequence increment the queue position*/
    rba_I2c_Prv_IncSendPosition_Queue( xLogicId_u8, xSeqPrio_en );

    /* Call end notification if present */
    if (rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[ xSequenceId_u8 ]->xSeqEndNotif_pfct != NULL_PTR)
    {
        (*rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[ xSequenceId_u8 ]->xSeqEndNotif_pfct)();
    }

    /* Set the BUS is not free error  */
    rba_I2c_Prv_JdpSeq_Run_st[xLogicId_u8].currentSeq->rba_I2c_xComErr_u8 = xErrorID_u8;

    /* Get the  data belonging to the index */
    rba_I2c_Prv_JdpSeq_Run_st[xLogicId_u8].currentSeq->rba_I2c_xSeqStatus_en = xSeqStatus;

    /* after complete the sequence execution set the Sequence status to IDLE */
    rba_I2c_Prv_stSequenceStatus_au8 [ xSequenceId_u8 ] = rba_I2c_QueueSequence_Idle_e;

    /* Sequence Handler status updates as Process Completed*/
    rba_I2c_Prv_stI2c_ChanRunStatus_en[ xLogicId_u8 ] = RBA_I2C_CHANNEL_NOT_RUNNING;
}

#define  RBA_I2C_STOP_SEC_CODE
#include RBA_I2C_CFG_MEMMAP_H

/* End of #ifdef RBA_I2C_CFG_MODULE_ACTIVE validation */
#endif

/* Enf of #if(MCU_RB_MACHINE_FAM == MCU_RB_JDP_UC1) validation */";
								- m_startRow = 52;
								- m_startCol_Short = 0;
								- m_endRow = 1248;
								- m_endCol_Short = 66;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
							{ IFileFragment 
								- _id = GUID 51ba5fa4-02c6-40d4-8e3f-97303336d135;
								- _name = "directive endif";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "#endif";
								- m_startRow = 1249;
								- m_startCol_Short = 1;
								- m_endRow = 1249;
								- m_endCol_Short = 7;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
							{ IFileFragment 
								- _id = GUID 947e36b0-004d-4ae6-a96d-0a2b77886d0c;
								- _name = "/*! @} */
/*<RBHead>
 *************************************************************************
 * List Of Changes
 *
 * $History$
 *
 *************************************************************************
</RBHead>*/";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "/*! @} */
/*<RBHead>
 *************************************************************************
 * List Of Changes
 *
 * $History$
 *
 *************************************************************************
</RBHead>*/
";
								- m_startRow = 1251;
								- m_startCol_Short = 1;
								- m_endRow = 1259;
								- m_endCol_Short = 12;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
						}
					}
					{ IFile 
						- _id = GUID dc6f67a3-f3f0-4608-ba99-4af27815ea9d;
						- _myState = 8192;
						- _properties = { IPropertyContainer 
							- Subjects = { IRPYRawContainer 
								- size = 2;
								- value = 
								{ IPropertySubject 
									- _Name = "CG";
									- Metaclasses = { IRPYRawContainer 
										- size = 1;
										- value = 
										{ IPropertyMetaclass 
											- _Name = "File";
											- Properties = { IRPYRawContainer 
												- size = 1;
												- value = 
												{ IProperty 
													- _Name = "HeaderDirectivePattern";
													- _Value = "";
													- _Type = String;
												}
											}
										}
									}
								}
								{ IPropertySubject 
									- _Name = "C_CG";
									- Metaclasses = { IRPYRawContainer 
										- size = 1;
										- value = 
										{ IPropertyMetaclass 
											- _Name = "File";
											- Properties = { IRPYRawContainer 
												- size = 4;
												- value = 
												{ IProperty 
													- _Name = "ImplementationFooter";
													- _Value = "";
													- _Type = MultiLine;
												}
												{ IProperty 
													- _Name = "ImplementationHeader";
													- _Value = "";
													- _Type = MultiLine;
												}
												{ IProperty 
													- _Name = "SpecificationFooter";
													- _Value = "";
													- _Type = MultiLine;
												}
												{ IProperty 
													- _Name = "SpecificationHeader";
													- _Value = "";
													- _Type = MultiLine;
												}
											}
										}
									}
								}
							}
						}
						- _name = "rba_I2CJdp_Isr";
						- _modifiedTimeWeak = 7.4.2017::11:33:39;
						- m_path = "";
						- m_type = implFile;
						- Fragments = { IRPYRawContainer 
							- size = 6;
							- value = 
							{ IFileFragment 
								- _id = GUID 8a1e6609-11f7-4900-8f4f-2f301d5838fb;
								- _name = "/*<RBHead>
 *************************************************************************
 *                                                                       *
 *                      ROBERT BOSCH GMBH                                *
 *                          STUTTGART                                    *
 *                                                                       *
 *          Alle Rechte vorbehalten - All rights reserved                *
 *                                                                       *
 *************************************************************************

 *************************************************************************
 *    Administrative Information (automatically filled in by eASEE)      *
 *************************************************************************
 *
 * $Filename__:$
 *
 * $Author____:$
 *
 * $Function__:$
 *
 *************************************************************************
 * $Domain____:$
 * $User______:$
 * $Date______:$
 * $Class_____:$
 * $Name______:$
 * $Variant___:$
 * $Revision__:$
 * $Type______:$
 * $State_____:$
 * $Generated_:$
 *************************************************************************
 *
 * $UniqueName:$
 * $Component_:$
 *
 *
 *************************************************************************
</RBHead>*/";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "/*<RBHead>
 *************************************************************************
 *                                                                       *
 *                      ROBERT BOSCH GMBH                                *
 *                          STUTTGART                                    *
 *                                                                       *
 *          Alle Rechte vorbehalten - All rights reserved                *
 *                                                                       *
 *************************************************************************

 *************************************************************************
 *    Administrative Information (automatically filled in by eASEE)      *
 *************************************************************************
 *
 * $Filename__:$
 *
 * $Author____:$
 *
 * $Function__:$
 *
 *************************************************************************
 * $Domain____:$
 * $User______:$
 * $Date______:$
 * $Class_____:$
 * $Name______:$
 * $Variant___:$
 * $Revision__:$
 * $Type______:$
 * $State_____:$
 * $Generated_:$
 *************************************************************************
 *
 * $UniqueName:$
 * $Component_:$
 *
 *
 *************************************************************************
</RBHead>*/
";
								- m_startRow = 1;
								- m_startCol_Short = 1;
								- m_endRow = 39;
								- m_endCol_Short = 12;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
							{ IFileFragment 
								- _id = GUID aa7754c0-f6e7-450b-93de-f5715ed2207c;
								- _name = "/*-------------------------------------------------------------------------------------------------------------------*
 * Includes
 *-------------------------------------------------------------------------------------------------------------------*/
/*!
 * \\rba_comp rba_I2C
 *  @{
 */";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "/*-------------------------------------------------------------------------------------------------------------------*
 * Includes
 *-------------------------------------------------------------------------------------------------------------------*/
/*!
 * \\rba_comp rba_I2C
 *  @{
 */
";
								- m_startRow = 41;
								- m_startCol_Short = 1;
								- m_endRow = 47;
								- m_endCol_Short = 4;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
							{ IFileFragment 
								- _id = GUID 0a3e6b99-c792-446d-808e-de6770bc98da;
								- _name = "directive if";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "#if((MCU_RB_MACHINE_FAM == MCU_RB_JDP_UC1) && (MCU_RB_MACHINE_DEV != MCU_RB_JDP_UC1_DEV1_ALL))";
								- m_startRow = 51;
								- m_startCol_Short = 1;
								- m_endRow = 51;
								- m_endCol_Short = 95;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
							{ IFileFragment 
								- _id = GUID 97f81666-9163-401a-ad69-921590590b07;
								- _name = "ifdef - block";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "
#if(RBA_I2C_CFG_MODULE_ACTIVE == STD_ON)

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
#include \"Det.h\"
#endif

///////////////////////////////////////////////////////////////////////////////
//! \\brief Function interface
//! This Isr routine will generated from the cpu, this request is created from
//! Transmit and Receive request complete ISR for I2C channel-0.
//!
//!
//! \\param Void
//!
//! \\return Void
//!
//! \\pre none
//!
//! \\post Enter a new I2C sequence into the queue.
//!
///////////////////////////////////////////////////////////////////////////////
#define  RBA_I2C_START_SEC_CODE
#include RBA_I2C_CFG_MEMMAP_H

void rba_I2c_HwUnit0_Isr_Proc(void)
{
#if(RBA_I2C_CFG_CHANNEL_CONF_AVAILABLE_0 == 1u)
    /* Local Variable */
    uint8                       xSequenceId_u8 = 0u;                            /* Sequence ID for the running sequence. */
    uint8                       idxLogicId_u8 = 0u;                             /* Logical ID for the I2C Hardware. */
    uint8                       xSeqCurrentPosition_u8 = 0u;                    /* Next sequence in the queue. */
    rba_I2c_PriorityType_ten    xSeqPrio_en = RBA_I2C_SEQ_LOW_PRIORITY;         /* Priority for the running sequence. */
    Std_ReturnType              stRet = E_NOT_OK;                               /* stauts value*/
    boolean                     xEndtransmit_u8 = TRUE;                         /* Status of last byte exectuion */


    //SchM_Enter_rba_I2c_Driver_ISR();

    /* Clear the Bus Interrupt Flag. */
    rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBSR |= ((uint8)(1uL << RBA_REG_I2C_IBSR_IBIF_POS));

    // Read the logical hardware Id from the slave configuration dataset.
    idxLogicId_u8 = rba_I2c_prv_cfgConfigType_pcst->hwUnitConfig_pcst[ RBA_I2C_CHANNEL_ZERO ]->LogicHwId_u8;

    /* Read the signal ID from the current running sequence*/
    xSequenceId_u8 = rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].currentSeq->rba_I2c_xSequenceCfgId_u8;

    /* Read the sequence priority */
    xSeqPrio_en = rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[xSequenceId_u8]->sequPrio_en;

    if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
    {
        /* Get the index of the next sequence which should be processed */
        xSeqCurrentPosition_u8 = rba_I2c_Prv_posnQueueDynamic_ast[ idxLogicId_u8 ].idxSendPos_u8;
    }
    else
    {
        /* Get the index of the next sequence which should be processed */
        xSeqCurrentPosition_u8 = rba_I2c_Prv_posnQueueHiPriDynamic_ast[ idxLogicId_u8 ].idxSendPos_u8;
    }

    /* Check the communication mode as Transmit  */
    if( ( (rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBCR) & ((uint8)(1u << RBA_REG_I2C_IBCR_TXRX_POS) ) ) != 0u )
    {

        /* Check whether the last byte of the transmission */
        if( (rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en == rba_I2c_Tx_e)  && (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8 >= rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqTxlength_u8) )
        {
            /* after complete the sequence execution set the Sequence status to IDLE */
            rba_I2c_Prv_stSequenceStatus_au8[ xSequenceId_u8 ] = rba_I2c_QueueSequence_Idle_e;

            if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
            {
                /* Get the  data belonging to the index */
                rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqCompleted_e;
            }
            else
            {
                /* Get the  data belonging to the index  from high priority queue*/
                rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqCompleted_e;
            }

            /* Send Stop command to the Slave device*/
            rba_I2c_JdpStop( RBA_I2C_CHANNEL_ZERO );

        }
        else
        {
            /* Check whether the Acknowledge is not recived */
            if ( ( (rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBSR) & ((uint8)(1uL <<RBA_REG_I2C_IBSR_RXAK_POS) ) ) != 0u )
            {
                /* after complete the sequence execution set the Sequence status to IDLE */
                rba_I2c_Prv_stSequenceStatus_au8[ xSequenceId_u8 ] = rba_I2c_QueueSequence_Idle_e;

                if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
                {
                    /* Sequence status set to failed */
                    rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                    /* Set the Sequence Error status to BUS is not free  */
                    rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_TX_ACK_NOT_RECEIVED;
                }
                else
                {
                    /* Sequence status set to failed */
                    rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                    /* Set the Sequence Error status to BUS is not free  */
                    rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_TX_ACK_NOT_RECEIVED;
                }

                /* Call the DET error for the Acknowledge failure TX mode*/
#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_ISR_CORE_0, RBA_I2C_DET_ERR_JDP_ISR_TX_ACK_NOT_RECEIVED);
#endif

                /* Send Stop command to the Slave device*/
                rba_I2c_JdpStop( RBA_I2C_CHANNEL_ZERO );

            }
            else
            {
                if(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en == rba_I2c_Tx_e)
                {
                    /* Send the data to I2C Bus */
                    rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBDR = rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataTx_pu8[ rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8 ];

                    /* Increment the Transmit data position */
                    rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8++;

                    //SchM_Exit_rba_I2c_Driver_ISR();

                    xEndtransmit_u8 = FALSE;

                }
                else if(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en == rba_I2c_CombinedTxRx_e )
                {
                    /* check whether the last byte transmission is completed */
                    if( (rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en == rba_I2c_CombinedTxRx_e ) && (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8 >= rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqTxlength_u8 ) )
                    {
                        /* In the combined TX-RX mode after complete the transmission enable Receive mode, for Send the Repeat Start command to the I2C Channel*/
                        rba_I2c_JdpReStart( RBA_I2C_CHANNEL_ZERO );

                        /* After the RE-START command wait till I2C bus go to busy state*/
                        stRet =  rba_I2c_Prv_waitTill_BusBusy( RBA_I2C_CHANNEL_ZERO);

                        /* Check whether the bus enter in to busy state in previous while condition */
                        if(stRet ==  E_NOT_OK )
                        {
                            /* after complete the sequence execution set the Sequence status to IDLE */
                            rba_I2c_Prv_stSequenceStatus_au8[ xSequenceId_u8 ] = rba_I2c_QueueSequence_Idle_e;

                            if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
                            {
                                /* Sequence status set to failed */
                                rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                                /* Set the Sequence Error status to BUS is not Busy  */
                                rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_COMB_RX_TX_BUS_NOT_BUSY;
                            }
                            else
                            {
                                /* Sequence status set to failed */
                                rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                                /* Set the Sequence Error status to BUS is not Busy  */
                                rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_COMB_RX_TX_BUS_NOT_BUSY;
                            }

                            /* Generate the DET error for the BUS is not enter in to BUSY state in combined TX mode*/
#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                            (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_ISR_CORE_0, RBA_I2C_DET_ERR_JDP_ISR_COMB_RX_TX_BUS_NOT_BUSY);
#endif

                            /* Send Stop command to the Slave device*/
                            rba_I2c_JdpStop( RBA_I2C_CHANNEL_ZERO );
                        }
                        else
                        {
                            /* Change the Communication mode form Transmit to receive */
                            rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en = rba_I2c_Rx_e;

                            /* Send Slave ID with Readmode in I2C channel*/
                            rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBDR = rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].slaveID_u8 + 1u;

                            xEndtransmit_u8 = FALSE;
                        }
                    }
                    else
                    {
                        /* Send the data to I2C Bus */
                        rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBDR = rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataTx_pu8[ rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8 ];

                        /* Increment the Transmit data position */
                        rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8++;

                        xEndtransmit_u8 = FALSE;
                    }
                }
                else
                {
                    /* Set to I2C Read Mode*/
                    rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBCR &= ((uint8)~(1uL << RBA_REG_I2C_IBCR_TXRX_POS));

                    /* Dummy Read required for as mentioned the JDP User Manuel */
                    *(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataRx_pu8) = (rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBDR);

                    if(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqRxlength_u8> 1uL)
                    {
                        /* Enable  the ACK for Transmission */
                        rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBCR &= ((uint8)~(1uL << RBA_REG_I2C_IBCR_NOACK_POS) );
                    }
                    else
                    {
                        /* Disable the ACK for Transmission */
                        rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBCR |= ((uint8)(1uL << RBA_REG_I2C_IBCR_NOACK_POS));
                    }

                    //SchM_Exit_rba_I2c_Driver_ISR();
                    xEndtransmit_u8 = FALSE;
                }
            }
        }
    }
    else
    {
        if(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en == rba_I2c_Rx_e)
        {
            /* check whether the last byte going to Receive */
            if( ( rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8 + 1uL) >= rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqRxlength_u8 )
            {
                /* Set to I2C Write Mode*/
                rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBCR |= ((uint8)( 1uL << RBA_REG_I2C_IBCR_TXRX_POS ) );

                /* Send Stop command to the Slave device*/
                rba_I2c_JdpStop( RBA_I2C_CHANNEL_ZERO );

                /* Read the Data from the Data Register */
                *(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataRx_pu8 + (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8) ) = (rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBDR);

                /* after complete the sequence execution set the Sequence status to IDLE */
                rba_I2c_Prv_stSequenceStatus_au8[ xSequenceId_u8 ] = rba_I2c_QueueSequence_Idle_e;

                if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
                {
                    /* Set sequence status to completed */
                    rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqCompleted_e;
                }
                else
                {
                    /* Set sequence status to completed */
                    rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqCompleted_e;
                }
            }
            else if( ( (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8) + 2u) == rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqRxlength_u8  )
            {
                /* Disable the ACK for Transmission */
                rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBCR |= ( (uint8)(1uL << RBA_REG_I2C_IBCR_NOACK_POS) );

                /* Read the Data from the Data Register */
                *(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataRx_pu8 + (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8) )   = (rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBDR);

                /* Read Counter position increment */
                rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8++;


                xEndtransmit_u8 = FALSE;
            }
            else
            {
                /* Read the Data from the Data Register */
                *(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataRx_pu8 + (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8) )   = (rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBDR);

                /* Read Counter position increment */
                rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8++;


                xEndtransmit_u8 = FALSE;
            }
        }
        else
        {
            /* after complete the sequence execution set the Sequence status to IDLE */
            rba_I2c_Prv_stSequenceStatus_au8[ xSequenceId_u8 ] = rba_I2c_QueueSequence_Idle_e;

            if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
            {
                /* Sequence status set to failed */
                rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                /* Set the BUS is not free error  */
                rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ][ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_COMTYPE_ERROR;
            }
            else
            {
                /* Sequence status set to failed */
                rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                /* Set the BUS is not free error  */
                rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ][ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_COMTYPE_ERROR;
            }

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
            (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_ISR_CORE_0, RBA_I2C_DET_ERR_JDP_ISR_RX_COMM_TYPE);
#endif

            /* Send Stop command to the Slave device*/
            rba_I2c_JdpStop( RBA_I2C_CHANNEL_ZERO );
        }
    }


    if( xEndtransmit_u8 == TRUE )
    {
        /* Disable the I2C hardware */
        rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBCR = ((uint8)(1uL << RBA_REG_I2C_IBCR_MDIS_POS) );

        /* Enable the I2C bus and default setting */
        rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ZERO ]->IBCR = ((uint8)(1uL << RBA_REG_I2C_IBCR_NOACK_POS) );

        /* Increment the Queue Send position counter */
        rba_I2c_Prv_IncSendPosition_Queue( idxLogicId_u8, xSeqPrio_en );

        /* call end notification if present */
        if (rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[ xSequenceId_u8 ]->xSeqEndNotif_pfct != NULL_PTR)
        {
            (*rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[ xSequenceId_u8 ]->xSeqEndNotif_pfct)();
        }

        /* Check the Entries in Queue */
        if ( ( rba_I2c_Prv_posnQueueDynamic_ast[ idxLogicId_u8 ].numEntries_u8 > 0u )
             ||  ( rba_I2c_Prv_posnQueueHiPriDynamic_ast[ idxLogicId_u8 ].numEntries_u8 > 0u ) )
        {
            /* If entries available call to the Sequence handler function continouly */
            rba_I2c_Prv_Handler(idxLogicId_u8);
        }
        else
        {
            /* Sequence Handler status updates as Process Completed*/
            rba_I2c_Prv_stI2c_ChanRunStatus_en[ idxLogicId_u8 ] = RBA_I2C_CHANNEL_NOT_RUNNING;

        }

    }

#endif /* end of #if(RBA_I2C_CFG_CHANNEL_CONF_AVAILABLE_0 == 1u) validation */
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//! \\brief Function interface
//! This Isr routine will generated from the cpu, this request is created from
//! Transmit and Receive request complete ISR for I2C channel-0.
//!
//!
//! \\param Void
//!
//! \\return Void
//!
//! \\pre none
//!
//! \\post Enter a new I2C sequence into the queue.
//!
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if(MCU_RB_MACHINE_DEV == MCU_RB_JDP_UC1_DEV4_ALL)
void rba_I2c_HwUnit1_Isr_Proc(void)
{
#if(RBA_I2C_CFG_CHANNEL_CONF_AVAILABLE_1 == 1u )
    /* Local Variable */
    uint8                       xSequenceId_u8 = 0u;                         /* Sequence ID for the running sequence. */
    uint8                       idxLogicId_u8 = 0u;                          /* Logical ID for the I2C Hardware. */
    uint8                       xSeqCurrentPosition_u8 = 0u;               /* Next sequence in the queue. */
    rba_I2c_PriorityType_ten    xSeqPrio_en=RBA_I2C_SEQ_LOW_PRIORITY;   /* Priority for the running sequence. */
    Std_ReturnType              stRet  = E_NOT_OK;
    boolean                     xEndtransmit_u8 = TRUE;

    /* Clear the Bus Interrupt Flag. */
    rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBSR |= ((uint8)(1uL << RBA_REG_I2C_IBSR_IBIF_POS) );

    // Read the logical hardware Id from the slave configuration dataset.
    idxLogicId_u8 = rba_I2c_prv_cfgConfigType_pcst->hwUnitConfig_pcst[ RBA_I2C_CHANNEL_ONE ]->LogicHwId_u8;

    /* Read the signal ID from the current running sequence*/
    xSequenceId_u8 = rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].currentSeq->rba_I2c_xSequenceCfgId_u8;

    /* Read the sequence priority */
    xSeqPrio_en = rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[xSequenceId_u8]->sequPrio_en;

    if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
    {
        /* Get the index of the next sequence which should be processed */
        xSeqCurrentPosition_u8 = rba_I2c_Prv_posnQueueDynamic_ast[ idxLogicId_u8 ].idxSendPos_u8;
    }
    else
    {
        /* Get the index of the next sequence which should be processed for the HIGH priority */
        xSeqCurrentPosition_u8 = rba_I2c_Prv_posnQueueHiPriDynamic_ast[ idxLogicId_u8 ].idxSendPos_u8;
    }

    /* Check the communication mode as Transmit  */
    if (((rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBCR) & ( (uint8)(1uL << RBA_REG_I2C_IBCR_TXRX_POS ) ) ) != 0u)
    {

        /* Check the Transmission has Completed. */
        if( (rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en == rba_I2c_Tx_e)  && (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8 >= rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqTxlength_u8) )
        {
            /* after complete the sequence execution set the Sequence status to IDLE */
            rba_I2c_Prv_stSequenceStatus_au8[ xSequenceId_u8 ] = rba_I2c_QueueSequence_Idle_e;

            if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
            {
            /* Get the  data belonging to the index */
            rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqCompleted_e;
            }
            else
            {
                /* Get the  data belonging to the index of HIGH priority queue */
                rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqCompleted_e;
            }

            /* Generate Stop signal */
            rba_I2c_JdpStop( RBA_I2C_CHANNEL_ONE );

        }
        else
        {
            /* Check whether the Acknowledge is received or not */
            if( ( (rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBSR) & ((uint8)(1uL << RBA_REG_I2C_IBSR_RXAK_POS) ) ) != 0u)
            {
                /* after complete the sequence execution set the Sequence status to IDLE */
                rba_I2c_Prv_stSequenceStatus_au8[ xSequenceId_u8 ] = rba_I2c_QueueSequence_Idle_e;

                if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
                {
                    /* Sequence status set to failed */
                    rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                    /* Set the BUS is not free error  */
                    rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_TX_ACK_NOT_RECEIVED;
                }
                else
                {
                    /* Sequence status set to failed */
                    rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                    /* Set the BUS is not free error  */
                    rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_TX_ACK_NOT_RECEIVED;
                }

                /* Call the DET error for the Acknowledge failure TX mode*/
#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_ISR_CORE_1, RBA_I2C_DET_ERR_JDP_ISR_TX_ACK_NOT_RECEIVED);
#endif

                /* Generate the stop signal */
                rba_I2c_JdpStop( RBA_I2C_CHANNEL_ONE );

            }
            else
            {
                if(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en == rba_I2c_Tx_e)
                {
                    /* Send the data to I2C Bus */
                    rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBDR = rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataTx_pu8[ rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8 ];

                    /* Increment the Transmit data position */
                    rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8++;

                    //SchM_Exit_rba_I2c_Driver_ISR();

                    xEndtransmit_u8 = FALSE;

                }
                else if(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en == rba_I2c_CombinedTxRx_e )
                {
                    /* check whether the last byte transmission is completed */
                    if( (rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en == rba_I2c_CombinedTxRx_e ) && (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8 >= rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqTxlength_u8 ) )
                    {
                        /* In the combined TX-RX mode after complete the transmission enable Receive mode, for Send the Repeat Start command to the I2C Channel*/
                        rba_I2c_JdpReStart( RBA_I2C_CHANNEL_ONE );

                        /* After the RE-START command wait till I2C bus go to busy state*/
                        stRet =  rba_I2c_Prv_waitTill_BusBusy( RBA_I2C_CHANNEL_ONE);

                        /* Check whether the bus enter in to busy state in previous while condition */
                        if(stRet == E_NOT_OK )
                        {
                            /* after complete the sequence execution set the Sequence status to IDLE */
                            rba_I2c_Prv_stSequenceStatus_au8[ xSequenceId_u8 ] = rba_I2c_QueueSequence_Idle_e;

                            if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
                            {
                                /* Sequence status set to failed */
                                rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                                /* Set the BUS is not free error  */
                                rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_COMB_RX_TX_BUS_NOT_BUSY;
                            }
                            else
                            {
                                /* Sequence status set to failed */
                                rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                                /* Set the Sequence Error status to BUS is not Busy  */
                                rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_COMB_RX_TX_BUS_NOT_BUSY;
                            }

                            /* Call the DET error for the BUS is not enter in to BUSY state in combined TX mode*/
            #if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
                                (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_ISR_CORE_1, RBA_I2C_DET_ERR_JDP_ISR_COMB_RX_TX_BUS_NOT_BUSY);
            #endif
                                    rba_I2c_JdpStop( RBA_I2C_CHANNEL_ONE );
                        }
                        else
                        {
                            /* Change the Communication mode form Transmit to receive */
                            rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en = rba_I2c_Rx_e;

                            /* Send Slave ID in I2C channel*/
                            rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBDR = rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].slaveID_u8 + 1u;

                            xEndtransmit_u8 = FALSE;
                        }
                    }
                    else
                    {
                        /* Send the data to I2C Bus */
                        rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBDR = rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataTx_pu8[ rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8 ];

                        /* Increment the Transmit data position */
                        rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataTxPosition_u8++;

                        xEndtransmit_u8 = FALSE;
                    }
                }
                else
                {
                    /* Set to I2C Read Mode*/
                    rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBCR &=  ((uint8)~(1uL << RBA_REG_I2C_IBCR_TXRX_POS) );

                    /* Dummy Read required for as mentioned the JDP User Manuel */
                    *(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataRx_pu8) = (rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBDR);

                    if(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqRxlength_u8 > 1uL)
                    {
                        /* Enable  the ACK for Transmission */
                        rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBCR &=  ((uint8)~(1uL << RBA_REG_I2C_IBCR_NOACK_POS));
                    }
                    else
                    {
                        /* Disable the ACK for Transmission */
                        rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBCR |= ((uint8)(1uL << RBA_REG_I2C_IBCR_NOACK_POS));
                    }

                    //SchM_Exit_rba_I2c_Driver_ISR();
                    xEndtransmit_u8 = FALSE;
                }
            }
        }
    }
    else
    {
        if(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqComType_en == rba_I2c_Rx_e)
        {
            /* check whether the last byte going to Receive */
            if( ( rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8 + 1uL) >= rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqRxlength_u8 )
            {
                /* Set to I2C Write Mode*/
                rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBCR |= ((uint8)( 1uL << RBA_REG_I2C_IBCR_TXRX_POS ));

                /* Send Stop command to the Slave device*/
                rba_I2c_JdpStop( RBA_I2C_CHANNEL_ONE );

                /* Disable the I2C hardware */
                *(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataRx_pu8 + (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8) ) = (rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBDR);

                /* after complete the sequence execution set the Sequence status to IDLE */
                rba_I2c_Prv_stSequenceStatus_au8[ xSequenceId_u8 ] = rba_I2c_QueueSequence_Idle_e;

                if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
                {
                    /* Set sequence status to completed */
                    rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqCompleted_e;
                }
                else
                {
                    /* Set sequence status to completed */
                    rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqCompleted_e;
                }
            }
            else if( ( (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8) + 2u) == rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runSeqRxlength_u8  )
            {
                /* Disable the ACK for Transmission */
                rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBCR |= ((uint8)(1uL << RBA_REG_I2C_IBCR_NOACK_POS));

                /* If entries available call to the Sequence handler function continouly */
                *(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataRx_pu8 + (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8) )   = (rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBDR);

                /* Sequence Handler status updates as Process Completed*/
                rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8++;


                xEndtransmit_u8 = FALSE;
            }
            else
            {
                /* Read the Data from the Data Register */
                *(rba_I2c_Prv_JdpSeq_Run_st[ idxLogicId_u8 ].runDataRx_pu8 + (rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8) )   = (rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBDR);

                /* Read Counter position increment */
                rba_I2c_Prv_SeqCount_st[ idxLogicId_u8 ].dataRxPosition_u8++;


                xEndtransmit_u8 = FALSE;
            }
        }
        else
        {
            /* after complete the sequence execution set the Sequence status to IDLE */
            rba_I2c_Prv_stSequenceStatus_au8[ xSequenceId_u8 ] = rba_I2c_QueueSequence_Idle_e;

            if(xSeqPrio_en == RBA_I2C_SEQ_LOW_PRIORITY)
            {
                /* Sequence status set to failed */
                rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                /* Set the BUS is not free error  */
                rba_I2c_Prv_adrSequenceQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_COMTYPE_ERROR;
            }
            else
            {

                rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xSeqStatus_en = rba_I2c_SeqFailed_e;

                /* Set the BUS is not free error  */
                rba_I2c_Prv_adrSequenceHiPriQueue_ast[ idxLogicId_u8 ] [ xSeqCurrentPosition_u8 ]->rba_I2c_xComErr_u8 = RBA_I2C_ERR_SEQ_JDP_ISR_COMTYPE_ERROR;
            }

#if (RBA_I2C_CFG_DEV_ERROR_DETECT == STD_ON)
            (void)Det_ReportError(RBA_I2C_MODULE_ID, RBA_I2C_INSTANCE_ID, RBA_I2C_APIID_JDP_HW_PRV_ISR_CORE_1, RBA_I2C_DET_ERR_JDP_ISR_RX_COMM_TYPE);
#endif
            rba_I2c_JdpStop( RBA_I2C_CHANNEL_ONE );
        }
    }

    /* Send Stop command to the Slave device*/

    if( xEndtransmit_u8 == TRUE )
    {
	    /* Disable the I2C hardware */
	    rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBCR = ((uint8)(1uL << RBA_REG_I2C_IBCR_MDIS_POS));

	    /* Enable the I2C bus and default setting */
	    rba_I2c_Prv_Address_apcst[ RBA_I2C_CHANNEL_ONE ]->IBCR = ((uint8)(1uL << RBA_REG_I2C_IBCR_NOACK_POS));

	    /* Increment the Queue Send position counter */
	    rba_I2c_Prv_IncSendPosition_Queue( idxLogicId_u8, xSeqPrio_en );

	    /* call end notification if present */
	    if (rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[ xSequenceId_u8 ]->xSeqEndNotif_pfct != NULL_PTR)
	    {
	        (*rba_I2c_prv_cfgConfigType_pcst->sequenceConfig_pcst[ xSequenceId_u8 ]->xSeqEndNotif_pfct)();
	    }
	    /* Check the Entries in Queue */
	    if ( ( rba_I2c_Prv_posnQueueDynamic_ast[ idxLogicId_u8 ].numEntries_u8 > 0u )
	         ||  ( rba_I2c_Prv_posnQueueHiPriDynamic_ast[ idxLogicId_u8 ].numEntries_u8 > 0u ) )
	    {
	        /* If entries available call to the Sequence handler function continuously */
	        rba_I2c_Prv_Handler(idxLogicId_u8);
	    }
	    else
	    {
	        /* Sequence Handler status updates as Process Completed*/
	        rba_I2c_Prv_stI2c_ChanRunStatus_en[ idxLogicId_u8 ] = RBA_I2C_CHANNEL_NOT_RUNNING;

	    }
    }

#endif  //end of #if(RBA_I2C_CFG_CHANNEL_CONF_AVAILABLE_1 == 1u )
}
#endif

#define  RBA_I2C_STOP_SEC_CODE
#include RBA_I2C_CFG_MEMMAP_H

/* end of  \"RBA_I2C_CFG_MODULE_ACTIVE\" */
#endif

/* end of #if(MCU_RB_MACHINE_FAM == MCU_RB_JDP_UC1) */";
								- m_startRow = 52;
								- m_startCol_Short = 0;
								- m_endRow = 741;
								- m_endCol_Short = 55;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
							{ IFileFragment 
								- _id = GUID 42949608-f3c3-4d4a-a9b7-e9c7399be61c;
								- _name = "directive endif";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "#endif";
								- m_startRow = 742;
								- m_startCol_Short = 1;
								- m_endRow = 742;
								- m_endCol_Short = 7;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
							{ IFileFragment 
								- _id = GUID cc407e4f-4364-4fb6-a1e4-76624ef568db;
								- _name = "/*! @} */
/*<RBHead>
 *************************************************************************
 * List Of Changes
 *
 * $History$
 *
 *************************************************************************
</RBHead>*/";
								- _modifiedTimeWeak = 1.2.1990::0:0:0;
								- m_type = textFragment;
								- m_text = "/*! @} */
/*<RBHead>
 *************************************************************************
 * List Of Changes
 *
 * $History$
 *
 *************************************************************************
</RBHead>*/
";
								- m_startRow = 744;
								- m_startCol_Short = 1;
								- m_endRow = 752;
								- m_endCol_Short = 12;
								- m_subject = { INObjectHandle 
									- _m2Class = "";
								}
							}
						}
					}
				}
			}
			{ IFile 
				- _id = GUID 5dd7c49d-78b7-4228-a09a-ae082be04adf;
				- _myState = 8192;
				- _properties = { IPropertyContainer 
					- Subjects = { IRPYRawContainer 
						- size = 2;
						- value = 
						{ IPropertySubject 
							- _Name = "CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 2;
										- value = 
										{ IProperty 
											- _Name = "AddToMakefile";
											- _Value = "False";
											- _Type = Bool;
										}
										{ IProperty 
											- _Name = "HeaderDirectivePattern";
											- _Value = "";
											- _Type = String;
										}
									}
								}
							}
						}
						{ IPropertySubject 
							- _Name = "C_CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 5;
										- value = 
										{ IProperty 
											- _Name = "Generate";
											- _Value = "False";
											- _Type = Enum;
											- _ExtraTypeInfo = "True, False, Specification, Implementation";
										}
										{ IProperty 
											- _Name = "ImplementationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "ImplementationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
									}
								}
							}
						}
					}
				}
				- _name = "rba_I2C_Cfg_SchM";
				- _modifiedTimeWeak = 5.8.2017::7:12:1;
				- m_path = "";
				- m_type = specFile;
				- Fragments = { IRPYRawContainer 
					- size = 0;
				}
			}
			{ IFile 
				- _id = GUID bc1fe47f-466c-4b9f-8e97-bf770ffbb572;
				- _myState = 8192;
				- _properties = { IPropertyContainer 
					- Subjects = { IRPYRawContainer 
						- size = 2;
						- value = 
						{ IPropertySubject 
							- _Name = "CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 2;
										- value = 
										{ IProperty 
											- _Name = "AddToMakefile";
											- _Value = "False";
											- _Type = Bool;
										}
										{ IProperty 
											- _Name = "HeaderDirectivePattern";
											- _Value = "";
											- _Type = String;
										}
									}
								}
							}
						}
						{ IPropertySubject 
							- _Name = "C_CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 5;
										- value = 
										{ IProperty 
											- _Name = "Generate";
											- _Value = "False";
											- _Type = Enum;
											- _ExtraTypeInfo = "True, False, Specification, Implementation";
										}
										{ IProperty 
											- _Name = "ImplementationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "ImplementationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
									}
								}
							}
						}
					}
				}
				- _name = "Det";
				- _modifiedTimeWeak = 5.8.2017::7:12:1;
				- m_path = "";
				- m_type = specFile;
				- Fragments = { IRPYRawContainer 
					- size = 0;
				}
			}
			{ IFile 
				- _id = GUID 4b4c220d-c8f8-41ea-9348-d717303bc5c9;
				- _myState = 8192;
				- _properties = { IPropertyContainer 
					- Subjects = { IRPYRawContainer 
						- size = 2;
						- value = 
						{ IPropertySubject 
							- _Name = "CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 2;
										- value = 
										{ IProperty 
											- _Name = "AddToMakefile";
											- _Value = "False";
											- _Type = Bool;
										}
										{ IProperty 
											- _Name = "HeaderDirectivePattern";
											- _Value = "";
											- _Type = String;
										}
									}
								}
							}
						}
						{ IPropertySubject 
							- _Name = "C_CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 5;
										- value = 
										{ IProperty 
											- _Name = "Generate";
											- _Value = "False";
											- _Type = Enum;
											- _ExtraTypeInfo = "True, False, Specification, Implementation";
										}
										{ IProperty 
											- _Name = "ImplementationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "ImplementationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
									}
								}
							}
						}
					}
				}
				- _name = "Std_Types";
				- _modifiedTimeWeak = 5.8.2017::7:12:1;
				- m_path = "";
				- m_type = specFile;
				- Fragments = { IRPYRawContainer 
					- size = 0;
				}
			}
			{ IFile 
				- _id = GUID a232a7ba-6030-4fc2-a8d0-f097e6bc4d67;
				- _myState = 8192;
				- _properties = { IPropertyContainer 
					- Subjects = { IRPYRawContainer 
						- size = 2;
						- value = 
						{ IPropertySubject 
							- _Name = "CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 2;
										- value = 
										{ IProperty 
											- _Name = "AddToMakefile";
											- _Value = "False";
											- _Type = Bool;
										}
										{ IProperty 
											- _Name = "HeaderDirectivePattern";
											- _Value = "";
											- _Type = String;
										}
									}
								}
							}
						}
						{ IPropertySubject 
							- _Name = "C_CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 5;
										- value = 
										{ IProperty 
											- _Name = "Generate";
											- _Value = "False";
											- _Type = Enum;
											- _ExtraTypeInfo = "True, False, Specification, Implementation";
										}
										{ IProperty 
											- _Name = "ImplementationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "ImplementationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
									}
								}
							}
						}
					}
				}
				- _name = "Mcu";
				- _modifiedTimeWeak = 5.8.2017::7:12:1;
				- m_path = "";
				- m_type = specFile;
				- Fragments = { IRPYRawContainer 
					- size = 0;
				}
			}
			{ IFile 
				- _id = GUID 813f69b6-c50c-4150-b414-eab3b84445d5;
				- _myState = 8192;
				- _properties = { IPropertyContainer 
					- Subjects = { IRPYRawContainer 
						- size = 2;
						- value = 
						{ IPropertySubject 
							- _Name = "CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 2;
										- value = 
										{ IProperty 
											- _Name = "AddToMakefile";
											- _Value = "False";
											- _Type = Bool;
										}
										{ IProperty 
											- _Name = "HeaderDirectivePattern";
											- _Value = "";
											- _Type = String;
										}
									}
								}
							}
						}
						{ IPropertySubject 
							- _Name = "C_CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 5;
										- value = 
										{ IProperty 
											- _Name = "Generate";
											- _Value = "False";
											- _Type = Enum;
											- _ExtraTypeInfo = "True, False, Specification, Implementation";
										}
										{ IProperty 
											- _Name = "ImplementationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "ImplementationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
									}
								}
							}
						}
					}
				}
				- _name = "rba_I2C_Cfg_MemMap";
				- _modifiedTimeWeak = 5.8.2017::7:12:1;
				- m_path = "";
				- m_type = specFile;
				- Fragments = { IRPYRawContainer 
					- size = 0;
				}
			}
			{ IFile 
				- _id = GUID e75ffb5d-ae2e-4911-bf16-49b94a409af2;
				- _myState = 8192;
				- _properties = { IPropertyContainer 
					- Subjects = { IRPYRawContainer 
						- size = 2;
						- value = 
						{ IPropertySubject 
							- _Name = "CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 2;
										- value = 
										{ IProperty 
											- _Name = "AddToMakefile";
											- _Value = "False";
											- _Type = Bool;
										}
										{ IProperty 
											- _Name = "HeaderDirectivePattern";
											- _Value = "";
											- _Type = String;
										}
									}
								}
							}
						}
						{ IPropertySubject 
							- _Name = "C_CG";
							- Metaclasses = { IRPYRawContainer 
								- size = 1;
								- value = 
								{ IPropertyMetaclass 
									- _Name = "File";
									- Properties = { IRPYRawContainer 
										- size = 5;
										- value = 
										{ IProperty 
											- _Name = "Generate";
											- _Value = "False";
											- _Type = Enum;
											- _ExtraTypeInfo = "True, False, Specification, Implementation";
										}
										{ IProperty 
											- _Name = "ImplementationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "ImplementationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationFooter";
											- _Value = "";
											- _Type = MultiLine;
										}
										{ IProperty 
											- _Name = "SpecificationHeader";
											- _Value = "";
											- _Type = MultiLine;
										}
									}
								}
							}
						}
					}
				}
				- _name = "rba_BswSrv";
				- _modifiedTimeWeak = 5.8.2017::7:12:1;
				- m_path = "";
				- m_type = specFile;
				- Fragments = { IRPYRawContainer 
					- size = 0;
				}
			}
		}
	}
	- m_configActive = { ICodeGenConfigInfoHandle 
		- _m2Class = "ICodeGenConfigInfo";
		- _id = GUID 1fc53da7-29e3-44dc-b2db-d76c147a0b55;
	}
	- Configs = { IRPYRawContainer 
		- size = 1;
		- value = 
		{ ICodeGenConfigInfo 
			- _id = GUID 1fc53da7-29e3-44dc-b2db-d76c147a0b55;
			- _myState = 8192;
			- _properties = { IPropertyContainer 
				- Subjects = { IRPYRawContainer 
					- size = 3;
					- value = 
					{ IPropertySubject 
						- _Name = "C_CG";
						- Metaclasses = { IRPYRawContainer 
							- size = 2;
							- value = 
							{ IPropertyMetaclass 
								- _Name = "Framework";
								- Properties = { IRPYRawContainer 
									- size = 1;
									- value = 
									{ IProperty 
										- _Name = "IncludeHeaderFile";
										- _Value = "OnlyOnAnimation";
										- _Type = Enum;
										- _ExtraTypeInfo = "Yes,OnlyOnAnimation,No";
									}
								}
							}
							{ IPropertyMetaclass 
								- _Name = "Package";
								- Properties = { IRPYRawContainer 
									- size = 1;
									- value = 
									{ IProperty 
										- _Name = "GenerateDirectory";
										- _Value = "False";
										- _Type = Bool;
									}
								}
							}
						}
					}
					{ IPropertySubject 
						- _Name = "C_ReverseEngineering";
						- Metaclasses = { IRPYRawContainer 
							- size = 2;
							- value = 
							{ IPropertyMetaclass 
								- _Name = "ImplementationTrait";
								- Properties = { IRPYRawContainer 
									- size = 5;
									- value = 
									{ IProperty 
										- _Name = "ImportAsExternal";
										- _Value = "False";
										- _Type = Bool;
									}
									{ IProperty 
										- _Name = "InterfaceOnly";
										- _Value = "False";
										- _Type = Bool;
									}
									{ IProperty 
										- _Name = "MapToPackage";
										- _Value = "User";
										- _Type = Enum;
										- _ExtraTypeInfo = "User,Directory";
									}
									{ IProperty 
										- _Name = "RootDirectory";
										- _Value = ".";
										- _Type = String;
									}
									{ IProperty 
										- _Name = "UserPackage";
										- _Value = "rba_I2c";
										- _Type = String;
									}
								}
							}
							{ IPropertyMetaclass 
								- _Name = "Parser";
								- Properties = { IRPYRawContainer 
									- size = 5;
									- value = 
									{ IProperty 
										- _Name = "AdditionalKeywords";
										- _Value = "far,near";
										- _Type = String;
									}
									{ IProperty 
										- _Name = "Defined";
										- _Value = "";
										- _Type = String;
									}
									{ IProperty 
										- _Name = "ForceExpansionMacros";
										- _Value = "";
										- _Type = String;
									}
									{ IProperty 
										- _Name = "IncludePath";
										- _Value = "api,src";
										- _Type = String;
									}
									{ IProperty 
										- _Name = "Undefined";
										- _Value = "";
										- _Type = String;
									}
								}
							}
						}
					}
					{ IPropertySubject 
						- _Name = "ReverseEngineering";
						- Metaclasses = { IRPYRawContainer 
							- size = 2;
							- value = 
							{ IPropertyMetaclass 
								- _Name = "Main";
								- Properties = { IRPYRawContainer 
									- size = 3;
									- value = 
									{ IProperty 
										- _Name = "Files";
										- _Value = "..\\";
										- _Type = String;
									}
									{ IProperty 
										- _Name = "RESelectedFileRoot";
										- _Value = "..\\..";
										- _Type = String;
									}
									{ IProperty 
										- _Name = "RESelectedInputSource";
										- _Value = "..\\..";
										- _Type = String;
									}
								}
							}
							{ IPropertyMetaclass 
								- _Name = "Update";
								- Properties = { IRPYRawContainer 
									- size = 2;
									- value = 
									{ IProperty 
										- _Name = "CreateObjectModelDiagrams";
										- _Value = "True";
										- _Type = Bool;
									}
									{ IProperty 
										- _Name = "Policy";
										- _Value = "Overwrite";
										- _Type = Enum;
										- _ExtraTypeInfo = "Overwrite,Merge";
									}
								}
							}
						}
					}
				}
			}
			- _name = "DefaultConfig";
			- _modifiedTimeWeak = 7.4.2017::11:59:25;
			- HyperLinks = { IRPYRawContainer 
				- size = 2;
				- value = 
				{ IMHyperLink 
					- _id = GUID 3cb8ed61-65e0-4570-b370-3291f360b776;
					- codeUpdateCGTime = 7.4.2017::11:59:25;
					- _modifiedTimeWeak = 7.4.2017::11:59:25;
					- _dependsOn = { INObjectHandle 
						- _m2Class = "";
					}
					- _linkDispName = "Edit Makefile";
					- _linkType = "FREE";
					- _linkTarget = "C:/MCAL/PVER/base/Mx18_Make/Mcal/rba_I2C/workspace/RhapsodyTr/Mcal/rba_I2C/rba_I2C/rba_I2C/DefaultComponent.mak";
					- isConfigurationFileHyperLink = 1;
				}
				{ IMHyperLink 
					- _id = GUID e7c66d59-5477-4d1d-bc23-da6e88c83365;
					- codeUpdateCGTime = 7.4.2017::11:59:25;
					- _modifiedTimeWeak = 7.4.2017::11:59:25;
					- _dependsOn = { INObjectHandle 
						- _m2Class = "";
					}
					- _linkDispName = "Edit Main File";
					- _linkType = "FREE";
					- _linkTarget = "C:/MCAL/PVER/base/Mx18_Make/Mcal/rba_I2C/rba_I2C/rba_I2C/doc/rba_I2c_dSD/..\\..\\..\\..\\workspace\\RhapsodyTr\\Mcal\\rba_I2C\\rba_I2C\\rba_I2C/./MainDefaultComponent";
					- isConfigurationFileHyperLink = 1;
				}
			}
			- EmbededFiles = { IRPYRawContainer 
				- size = 1;
				- value = 
				{ IEmbededFile 
					- _id = GUID b25fcfcd-ad39-441c-a0cc-5795d42d8b26;
					- _name = "CollectedMacros.h";
					- _modifiedTimeWeak = 1.2.1990::0:0:0;
					- _MayNeedToRelocate = 0;
					- _LastKnownFullPath = "C:\\MCAL\\PVER\\base\\Mx18_Make\\Mcal\\rba_I2C\\rba_I2C\\rba_I2C\\doc\\rba_I2c_dSD\\rba_I2c_dSD_rpy\\CollectedMacros.h";
				}
			}
			- _scopeType = Explicit;
			- _libraries = "";
			- _additionalSources = "";
			- _standardHeaders = "";
			- _includePath = "";
			- _targetMain = "";
			- _instrumentation = None;
			- _timeModel = RealTime;
			- m_generateActors = 1;
			- _statechartImplementation = Flat;
			- _initializationCode = "";
			- _checksList = 0 ;
			- ScopeElements = { IRPYRawContainer 
				- size = 0;
			}
			- InitialInstances = { IRPYRawContainer 
				- size = 0;
			}
			- _root = { IFolder 
				- _id = GUID edb5b432-863a-4d11-ae90-0add43a8e73d;
				- _myState = 8192;
				- _name = "DefaultConfig";
				- _modifiedTimeWeak = 1.2.1990::0:0:0;
				- m_path = ".";
				- Elements = { IRPYRawContainer 
					- size = 0;
				}
				- Files = { IRPYRawContainer 
					- size = 0;
				}
			}
			- weakCGTime = 7.4.2017::11:59:25;
			- strongCGTime = 5.8.2017::7:12:2;
			- AnimScopeElements = { IRPYRawContainer 
				- size = 0;
			}
			- m_allInAnimScope = 1;
			- m_generateUsecases = 0;
		}
	}
	- HandlesInMe = { IRPYRawContainer 
		- size = 4;
		- value = 
		{ IHandle 
			- _m2Class = "ISubsystem";
			- _filename = "rba_I2c.sbs";
			- _subsystem = "";
			- _class = "";
			- _name = "rba_I2c";
			- _id = GUID 25e56b82-65b2-4104-bf9d-a5d545a5b30d;
		}
		{ IHandle 
			- _m2Class = "IProfile";
			- _filename = "$OMROOT\\Settings\\SoftwareArchitect\\SoftwareArchitect752C.sbs";
			- _subsystem = "";
			- _class = "";
			- _name = "SoftwareArchitectC";
			- _id = GUID 73d1c273-f433-4c6d-bb23-abfbac55b0aa;
		}
		{ IHandle 
			- _m2Class = "IProfile";
			- _filename = "$OMROOT\\Settings\\CodeCentric\\\\CodeCentric752C.sbs";
			- _subsystem = "";
			- _class = "";
			- _name = "CodeCentricC";
			- _id = GUID b2503309-cb02-4df3-88ac-b10f4bb6aaf0;
		}
		{ IHandle 
			- _m2Class = "IProfile";
			- _filename = "DGS_EC_SoftwareArch_Profile.sbs";
			- _subsystem = "";
			- _class = "";
			- _name = "DGS_EC_SoftwareArch_Profile";
			- _id = GUID 8933c50e-92db-4c03-b5c8-2fa194f54d9e;
		}
	}
	- VariationPoints = { IRPYRawContainer 
		- size = 0;
	}
	- SelectedVariants = { IRPYRawContainer 
		- size = 0;
	}
	- weakCGTime = 7.4.2017::11:57:58;
	- strongCGTime = 1.2.1990::0:0:0;
}

